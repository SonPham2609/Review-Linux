# Linux File System
* Hệ thống tệp (file) Linux là một tập hợp có cấu trúc các tệp trên ổ đĩa hoặc một phân vùng. Phân vùng là một phân đoạn bộ nhớ và chứa một số dữ liệu cụ thể. Trong máy của chúng ta, có thể có nhiều phân vùng bộ nhớ khác nhau. Nói chung, mọi phân vùng đều chứa một hệ thống tệp.
* Hệ thống máy tính đa năng cần lưu trữ dữ liệu một cách có hệ thống để chúng ta có thể dễ dàng truy cập các tệp trong thời gian ngắn hơn. Nó lưu trữ dữ liệu trên đĩa cứng (HDD) hoặc một số loại lưu trữ tương đương. Có thể có những lý do dưới đây để duy trì hệ thống tệp:

    * Chủ yếu máy tính lưu dữ liệu vào bộ nhớ RAM; nó có thể mất dữ liệu nếu nó bị tắt. Tuy nhiên, có sẵn RAM bất biến (RAM Flash và SSD) để duy trì dữ liệu sau khi ngắt nguồn.

    * Việc lưu trữ dữ liệu được ưu tiên trên ổ cứng so với RAM tiêu chuẩn vì RAM tốn nhiều dung lượng hơn dung lượng đĩa. Chi phí đĩa cứng đang giảm dần so với RAM.
* Hệ thống tệp Linux chứa các phần sau:

    * Thư mục gốc (/)

    * Định dạng lưu trữ dữ liệu cụ thể (EXT3, EXT4, BTRFS, XFS, v.v.)

    * Một phân vùng hoặc ổ đĩa hợp lý có một hệ thống tệp cụ thể.
## Cấu trúc hệ thống tệp Linux
* Hệ thống tệp Linux có cấu trúc tệp phân cấp vì nó chứa thư mục gốc và các thư mục con của nó.ất cả các thư mục khác có thể được truy cập từ thư mục gốc. Một phân vùng thường chỉ có một hệ thống tệp, nhưng nó có thể có nhiều hơn một hệ thống tệp.

*  Hệ thống tệp được thiết kế theo cách để nó có thể quản lý và cung cấp không gian cho dữ liệu lưu trữ không thay đổi. Tất cả các hệ thống tệp đều yêu cầu một không gian tên là phương pháp đặt tên và tổ chức. Không gian tên xác định quy trình đặt tên, độ dài của tên tệp hoặc một tập hợp con các ký tự có thể được sử dụng cho tên tệp. Nó cũng xác định cấu trúc logic của các tệp trên một phân đoạn bộ nhớ, chẳng hạn như việc sử dụng các thư mục để tổ chức các tệp cụ thể. Khi không gian tên được mô tả, mô tả Siêu dữ liệu phải được xác định cho tệp cụ thể đó.

* Cấu trúc dữ liệu cần hỗ trợ cấu trúc thư mục phân cấp; cấu trúc này được sử dụng để mô tả không gian đĩa có sẵn và được sử dụng cho một khối cụ thể. Nó cũng có các chi tiết khác về tệp như kích thước tệp, ngày và giờ tạo, cập nhật và sửa đổi lần cuối.
* Ngoài ra, nó lưu trữ thông tin nâng cao về phần của đĩa, chẳng hạn như phân vùng và ổ đĩa.

* Dữ liệu nâng cao và cấu trúc mà nó đại diện chứa thông tin về hệ thống tệp được lưu trữ trên ổ đĩa; nó khác biệt và độc lập với siêu dữ liệu hệ thống tệp.

* Hệ thống tệp Linux chứa kiến ​​trúc triển khai phần mềm hệ thống tệp gồm hai phần. Hãy xem xét hình ảnh dưới đây:

![image](https://user-images.githubusercontent.com/91528234/199150030-927ce7b2-c770-48e8-86f5-70b0e92f6eeb.png)

* Hệ thống tệp yêu cầu một API (Giao diện lập trình ứng dụng) để truy cập các lệnh gọi hàm để tương tác với các thành phần của hệ thống tệp như tệp và thư mục. API hỗ trợ các tác vụ như tạo, xóa và sao chép tệp. Nó tạo điều kiện cho một thuật toán xác định sự sắp xếp của các tệp trên một hệ thống tệp.

* Hai phần đầu tiên của hệ thống tệp nhất định được gọi là hệ thống tệp ảo Linux. Nó cung cấp một bộ lệnh duy nhất để hạt nhân và các nhà phát triển truy cập vào hệ thống tệp. Hệ thống tệp ảo này yêu cầu trình điều khiển hệ thống cụ thể cung cấp giao diện cho hệ thống tệp.
## Các tính năng của hệ thống tệp Linux
* Trong Linux, hệ thống tệp tạo ra một cấu trúc cây. Tất cả các tệp được sắp xếp như một cái cây và các nhánh của nó. Thư mục trên cùng được gọi là thư mục gốc (/). Tất cả các thư mục khác trong Linux có thể được truy cập từ thư mục gốc.

* Một số tính năng chính của hệ thống tệp Linux như sau:

    * **Chỉ định đường dẫn**: Sử dụng dấu gạch chéo (/) để chia các thành phần. Dữ liệu sẽ được lưu trữ trong /home/MyDocument/Work.

    * **Phân vùng, Thư mục và Ổ đĩa**: Linux không sử dụng ký tự ổ đĩa để tổ chức ổ đĩa như Windows. Trong Linux,  không thể biết liệu chúng đang định địa chỉ một phân vùng, một thiết bị mạng hay một thư mục "thông thường" và một Ổ đĩa.

    * **Phân biệt chữ hoa chữ thường**: Hệ thống tệp Linux phân biệt chữ hoa chữ thường. Nó phân biệt giữa tên tệp viết thường và viết hoa. Chẳng hạn, có sự khác biệt giữa test.txt và Test.txt trong Linux. Quy tắc này cũng được áp dụng cho các thư mục và lệnh Linux.

    * **Phần mở rộng tệp**: Trong Linux, tệp có thể có phần mở rộng là '.txt', nhưng không nhất thiết tệp phải có phần mở rộng tệp. Trong khi làm việc với Shell, nó tạo ra một số vấn đề cho người mới bắt đầu để phân biệt giữa các tệp và thư mục. Nếu chúng ta sử dụng trình quản lý tệp đồ họa, nó tượng trưng cho các tệp và thư mục.

    * **Tệp ẩn**: Linux phân biệt giữa tệp tiêu chuẩn và tệp ẩn, hầu hết các tệp cấu hình được ẩn trong Hệ điều hành Linux. Thông thường, chúng ta không cần truy cập hoặc đọc các tệp ẩn. Các tệp ẩn trong Linux được biểu thị bằng dấu chấm (.) Trước tên tệp (ví dụ: .ignore). Để truy cập các tệp, chúng ta cần thay đổi chế độ xem trong trình quản lý tệp hoặc cần sử dụng một lệnh cụ thể trong trình bao.
 ## Các loại hệ thống tệp Linux
 * Khi chúng ta cài đặt hệ điều hành Linux, Linux cung cấp nhiều hệ thống tệp như Ext, Ext2, Ext3, Ext4, JFS, ReiserFS, XFS, btrfs và swap.
 ![image](https://user-images.githubusercontent.com/91528234/199150947-0ed029a9-49bb-4fbd-b38b-541b2e71dd5f.png)
 ### Ext, Ext2, Ext3 and Ext4 file system
 * Hệ thống tập tin Ext là viết tắt của **Extended File System**. Nó chủ yếu được phát triển cho **MINIX OS**. Hệ thống tệp Ext là phiên bản cũ hơn và không còn được sử dụng do một số hạn chế.

* **Ext2** là hệ thống tệp Linux đầu tiên cho phép quản lý hai terabyte dữ liệu. Ext3 được phát triển thông qua Ext2; nó là phiên bản nâng cấp của Ext2 và có khả năng tương thích ngược. Hạn chế lớn của Ext3 là không hỗ trợ máy chủ vì hệ thống tệp này không hỗ trợ khôi phục tệp và ảnh chụp nhanh đĩa.

* Hệ thống tệp **Ext4** là hệ thống tệp nhanh hơn trong số tất cả các hệ thống tệp Ext. Đây là một tùy chọn rất tương thích cho các đĩa SSD (ổ thể rắn) và nó là hệ thống tệp mặc định trong bản phân phối Linux.
### JFS File System
* **JFS** là viết tắt của **Journaled File System**, và nó được **IBM phát triển cho AIX Unix**. Nó là một thay thế cho hệ thống tệp Ext. Nó cũng có thể được sử dụng thay cho Ext4, nơi cần sự ổn định với ít tài nguyên. Nó là một hệ thống tệp tiện dụng khi sức mạnh của CPU bị hạn chế.

### Hệ thống tệp ReiserFS

**ReiserFS** là một giải pháp thay thế cho hệ thống tệp Ext3. Nó đã được cải thiện hiệu suất và các tính năng nâng cao. Trong thời gian trước đó, ReiserFS được sử dụng làm hệ thống tệp mặc định trong SUSE Linux, nhưng sau đó nó đã thay đổi một số chính sách nên SUSE quay trở lại Ext3. Hệ thống tệp này hỗ trợ động phần mở rộng tệp, nhưng nó có một số hạn chế về hiệu suất.


### Hệ thống tệp XFS

* Hệ thống tệp **XFS** được coi là JFS tốc độ cao, được phát triển để xử lý I/O song song. NASA vẫn đang sử dụng hệ thống tệp này với máy chủ lưu trữ cao (máy chủ 300+ Terabyte).

### Hệ thống tệp Btrfs

* **Btrfs** là viết tắt của hệ thống tệp B cây. Nó được sử dụng để chịu lỗi, sửa chữa hệ thống, quản trị vui vẻ, cấu hình lưu trữ mở rộng và hơn thế nữa. Nó không phải là một phù hợp tốt cho hệ thống sản xuất.

### Hoán đổi hệ thống tệp

Hệ thống tệp hoán đổi được sử dụng để phân trang bộ nhớ trong hệ điều hành Linux trong chế độ ngủ đông của hệ thống. Một hệ thống không bao giờ ở trạng thái ngủ đông bắt buộc phải có không gian hoán đổi bằng với kích thước RAM của nó.

# Lệnh Fsck trong linux (sửa chữa hệ thống tập tin)
* fsck (kiểm tra hệ thống tệp) là một tiện ích dòng lệnh cho phép bạn thực hiện kiểm tra tính nhất quán và sửa chữa tương tác trên một hoặc nhiều hệ thống tệp Linux. Nó sử dụng các chương trình dành riêng cho loại hệ thống tập tin mà nó kiểm tra.
## Cách sử dụng fsck
Lệnh fsck có dạng chung sau:
```
fsck
```
* Chỉ người dùng root hoặc người dùng có quyền sudo có thể xóa bộ đệm.

* Khi không có `FILESYSTEM` nào được cung cấp làm đối số, fsck kiểm tra các thiết bị được liệt kê trong tệp fstab .

* Không bao giờ chạy fsck trên các phân vùng được gắn vì nó có thể làm hỏng hệ thống tệp. Trước khi thử kiểm tra hoặc sửa chữa các hệ thống tập tin luôn `unmount` nó trước.

* Lệnh fsck là một trình bao bọc cho các trình kiểm tra hệ thống tệp Linux khác nhau ( fsck.* ) Và chấp nhận các tùy chọn khác nhau tùy thuộc vào loại hệ thống tệp.

Kiểm tra các trang hướng dẫn để biết thêm thông tin về một trình kiểm tra cụ thể. Ví dụ: để xem các tùy chọn khả dụng cho fsck.ext4 , hãy nhập:
```
man fsck.ext4
```
## Khi nào thì dùng fsck trong Linux
* Có nhiều tình huống khác nhau khi bạn muốn chạy fsck. Dưới đây là một số ví dụ:

* Hệ thống không khởi động được.

* Các tệp trên hệ thống bị hỏng (thường thì bạn có thể thấy lỗi đầu vào/đầu ra).

* Ổ đĩa đính kèm (bao gồm ổ đĩa flash/thẻ SD) không hoạt động như mong đợi.
## Các tùy chọn có sẵn của fsck
* Lệnh Fsck cần được chạy với các đặc quyền của superuser hoặc **root**. Bạn có thể sử dụng nó với các đối số khác nhau. Việc sử dụng chúng tùy thuộc vào trường hợp cụ thể của bạn. Dưới đây, bạn sẽ thấy một số tùy chọn quan trọng hơn:

|COMMAND| ACTION |
| :---- | :---- |
-A | - Được sử dụng để kiểm tra tất cả các hệ thống tập tin. Danh sách được lấy từ / etc / fstab.
-C | - Hiển thị thanh tiến trình.
-l | - Khóa thiết bị để đảm bảo không có chương trình nào khác cố gắng sử dụng phân vùng trong quá trình kiểm tra.
-M | - Không kiểm tra hệ thống tập tin được gắn kết.
-N | - Chỉ hiển thị những gì sẽ được thực hiện - không có thay đổi thực tế nào được thực hiện.
-P | - Nếu bạn muốn kiểm tra song song các hệ thống tập tin, bao gồm cả root.
-R | - Không kiểm tra hệ thống tập tin gốc. Điều này chỉ hữu ích với ‘-A‘.
-r | - Cung cấp số liệu thống kê cho từng thiết bị đang được kiểm tra.
-T | - Không hiển thị tiêu đề.
-t | - Chỉ định riêng các loại hệ thống tệp được kiểm tra. Các loại có thể là danh sách được phân tách bằng dấu phẩy.
-V | - Cung cấp mô tả những gì đang được thực hiện.
## Cách chạy fsck để sửa lỗi hệ thống tệp Linux
* Trường hợp sử dụng đơn giản nhất của lệnh fsck là sửa chữa một hệ thống tệp ext3 hoặc ext4 không root bị hỏng.

* Ngắt kết nối thiết bị:
```
sudo umount /dev/sda1
```
Chạy fsck để sửa chữa hệ thống tập tin:
```
sudo fsck -p /dev/sda1
```
Tùy chọn `-p` yêu cầu fsck tự động sửa chữa mọi sự cố có thể được khắc phục một cách an toàn mà không cần sự can thiệp của người dùng.

Khi hệ thống tập tin được sửa chữa, gắn kết phân vùng:
```
sudo mount /dev/sda1
```
# Monitoring Disk
## Lệnh df
* Lệnh “df” viết tắt của “disk filesystem“, nó được dùng để lấy toàn bộ thông tin về lượng ổ cứng khả dụng và lượng ổ cứng đã dùng của các file hệ thống trên linux. Cách đơn giản nhất để kiểm tra dung lượng đĩa là ta sử dụng lệnh `df`:

![image](https://user-images.githubusercontent.com/91528234/199157000-dbc89421-d653-4972-9431-1500436c6898.png)

* Trong đó:

   * filesystem: tên filesystem có thể trùng với phân vùng đĩa.
   * 1K-blocks: Số lượng khối (block) có trong filesystem có kích thước 1Kb.
   * Used: Số lượng 1K-block được sử dụng trong filesystem.
   * Available: Số lượng 1K-block đang có sẵn.
   * Use%: Phần trăm đĩa đã sử dụng trong filesystem.
   * Mounted on: Nơi mount.
* Lệnh `df` được đi kèm với một số tùy chọn để hiển thị nội dung rõ ràng và thân thiện với người dùng hơn.
Tùy chọn `-h` cho ta một cái nhìn trực quan hơn khi đọc các thông số ở chế độ chi tiết : bytes, megabytes và gigabytes.

![image](https://user-images.githubusercontent.com/91528234/199157332-6daa82b5-b3ef-4f01-8993-e8cba2c45b42.png)
## Kiểm tra dung lượng đĩa với các trường hợp cụ thể
* Để kiểm tra space của một đĩa/phân vùng cụ thể, bạn sử dụng lệnh df với cú pháp:
```
df <option> path
```
* Một số ví dụ:
     * Kiểm tra dung lượng ổ đĩa phân vùng
     ![image](https://user-images.githubusercontent.com/91528234/199157667-92a505ad-f319-445a-abce-472026e42db6.png)
* Bạn có thể cờ `output` đi kèm lệnh df:
```
df -h --output='field1', 'field2' /
```
      Kiểm tra kích thước và phần trăm đĩa đã sử dụng, ta gõ lệnh:
      ![image](https://user-images.githubusercontent.com/91528234/199157947-dd02236c-d3c5-4e2f-919f-cf5f735ac495.png)
## Lệnh du
* du là một công cụ dòng lệnh được cung cấp bởi Linux, nhằm báo cáo dung lượng ổ đĩa được sử dụng bởi các thư mục và **file.du** là viết tắt của từ “disk usage”. Đây là công cụ chính để phân tích không gian ổ đĩa trong dòng lệnh.
```
du <option> <path|file>
du <option> <path1> <path2> <path3>  
```
* Kiểm tra dung lượng của một file cụ thể
Ví dụ để kiểm tra kích thước của một file .bashrc, bạn có thể chạy lệnh:
![image](https://user-images.githubusercontent.com/91528234/199158729-4e8d56f6-ada1-49a2-8fef-75e0cef44589.png)
## Kiểm tra dung lượng đĩa đã sử dụng cho các thư mục
* Bạn có thể kiểm tra dung lượng đĩa được sử dụng cho thư mục bằng lệnh du với tên đường dẫn cụ thể. Tuy nhiên trong một vài trường hợp bạn không muốn nhìn thấy output của tất cả file hoặc thư mục riêng lẻ, bạn có thể sử dụng tùy chọn `-shc`. Ví dụ dưới đây, tôi muốn kiểm tra dung lượng đĩa đã sử dụng cho thư mục /home hoặc /var/log.
![image](https://user-images.githubusercontent.com/91528234/199159211-4b39670c-9169-463c-8549-bbd019cc67c7.png)
* Ý nghĩa của các tùy chọn:

   * `-s`: dùng để tóm tắt, nó sẽ hiển thị tổng số đường dẫn được cung cấp thay vì hiển thị danh sách tất cả các tệp và thư mục.
   * `-h`: để con người có thể đọc được, nó sẽ hiển thị kết quả với các đơn vị.
   * `-c`: đối với tổng số lớn, nếu bạn chỉ định nhiều đường dẫn, nó sẽ tổng hợp chúng để tạo ra tổng số lớn cho chúng.
   # Tạo file Systems
   
* Lệnh mkfs xây dựng hệ thống tệp trên thiết bị khối:
```
# mkfs [option] device
```
* mkfs là giao diện người dùng cho các tiện ích trình tạo trong /sbin chẳng hạn như **mkfs.ext4**. Bạn có thể sử dụng lệnh mkfs với tùy chọn `-t` fstype hoặc tiện ích trình tạo để chỉ định loại hệ thống tệp cần xây dựng. Ví dụ: các lệnh sau là các cách tương đương để tạo hệ thống tệp ext4 với nhãn Dự án trên thiết bị /dev/sdb1:
```
# mkfs -t ext4 -L Projects /dev/sdb1
# mkfs.ext4 -L Projects /dev/sdb1
```
* và xem file đã được khởi tạo chưa với lệnh
```
lsblk
```
# Mounting and Unmounting Filesystems
* Để truy cập nội dung của hệ thống tệp, bạn phải gắn thiết bị khối của nó vào một điểm gắn kết trong hệ thống phân cấp thư mục. Bạn có thể sử dụng lệnh mkdir để tạo một thư mục để sử dụng làm điểm gắn kết, ví dụ:
```
# mkdir /var/project
```

* Bạn có thể sử dụng một thư mục hiện có làm điểm gắn kết, nhưng nội dung của nó sẽ bị ẩn cho đến khi bạn ngắt kết nối hệ thống tệp cơ bản.

* Lệnh mount sẽ gắn thiết bị chứa hệ thống tệp vào điểm mount:
```
# mount [options] device mount_point 
```

* Bạn có thể chỉ định thiết bị theo tên, UUID hoặc nhãn của nó. Ví dụ: các lệnh sau là các cách tương đương để gắn hệ thống tệp trên thiết bị khối /dev/sdb1:
```
# mount /dev/sdb1/var/project
# mount LABEL = "projects" /var/project
```

* Nếu bạn không chỉ định bất kỳ đối số nào, mount sẽ hiển thị tất cả các hệ thống tệp mà hệ thống hiện đã gắn kết, ví dụ:
```
# mout
/dev/mapper/vg_host01-lv_root on / type ext4 (rw)
...
```
* Trong ví dụ này, LVM logic volume/dev/mapper/ vg_host01-lv_root được gắn trên /. Loại hệ thống tệp là ext4 và được gắn cho cả việc đọc và ghi. (Bạn cũng có thể sử dụng lệnh cat /proc/mounts để hiển thị thông tin về hệ thống tệp được gắn kết.)

Lệnh df hiển thị thông tin về không gian còn lại trong nhà trên các hệ thống tệp được gắn kết, ví dụ:
```
# df -h
Filesystem                     Size  Used Avail Use% Mounted on
/dev/mapper/vg_host01-lv_root  36G   12G   22G  36% /
...
```

* Bạn có thể sử dụng tùy chọn -B (bind) cho lệnh mount để gắn thiết bị khối tại nhiều điểm mount. Bạn cũng có thể đếm lại một phần của hệ thống phân cấp thư mục, không cần phải là một hệ thống tệp hoàn chỉnh, ở một nơi khác. Ví dụ, lệnh sau mounts /var/project/project1 on/mnt:
```
# mount -B /var/projects/project1 /mnt
```
* Mỗi hệ thống phân cấp thư mục hoạt động như một bản sao của hệ thống phân cấp khác. Các tệp giống nhau đều có thể truy cập được ở cả hai vị trí, mặc dù bất kỳ số lượng con nào không được sao chép. Những gương này không cung cấp dự phòng dữ liệu.

* Bạn cũng có thể gắn kết một tệp trên một tệp khác, ví dụ:
```
# touch /mnt/foo

# mount -B /etc/hosts/mnt/foo
```
* Trong ví dụ này, /etc/hosts và /mnt/foo đại diện cho cùng một tệp. Không thể truy cập tệp hiện có hoạt động như một điểm gắn kết cho đến khi bạn ngắt kết nối tệp bên trên.

Tùy chọn `-B` không đính kèm đệ quy bất kỳ tài khoản con nào bên dưới hệ thống phân cấp thư mục. Để bao gồm các số lượng con trong nhân bản, hãy sử dụng tùy chọn `-R` (liên kết đệ quy) để thay thế.

Khi bạn sử dụng `-B` hoặc `-R`, các tùy chọn gắn kết hệ thống tệp vẫn giống như các tùy chọn cho điểm gắn kết ban đầu. Để sửa đổi các tùy chọn gắn kết, hãy sử dụng một lệnh remount riêng, ví dụ:
```
# mount -o remount,ro /mnt/foo
```
* Để ngắt kết nối hệ thống tệp, hãy sử dụng lệnh umount, ví dụ:
```
# umount /var/project
```
# Partitioning Disks( Phân vùn ổ đĩa)
* Phân vùng đĩa là quá trình chia đĩa thành một hoặc nhiều vùng được gọi là phân vùng. Bảng phân vùng nằm trong khu vực đầu tiên của đĩa và lưu trữ thông tin về kích thước và vị trí của các phân vùng đã tạo. Nói cách khác, phân vùng đĩa cho phép chia một ổ đĩa vật lý thành các ổ đĩa logic nhỏ hơn được gọi là ổ đĩa. Đối với một hệ điều hành, các ổ đĩa này hoàn toàn riêng biệt, vì vậy bạn có thể thực hiện các thao tác trên một ổ đĩa mà không ảnh hưởng đến các ổ đĩa khác.

* Hầu hết người dùng sẽ không bao giờ gặp phải nhu cầu phân vùng đĩa, nhưng phân vùng đĩa có thể hữu ích trong một số trường hợp.

   * Một ổ cứng mới thực tế không thể sử dụng được trừ khi nó được phân vùng để lưu dữ liệu.

   * Các phân vùng có thể được sử dụng để tổ chức dữ liệu theo kiểu của chúng. Ví dụ: bạn có thể có một phân vùng lưu trữ tất cả các tài liệu của bạn và một phân vùng khác lưu trữ tất cả các tệp nhạc của bạn.

   * Windows có thể dễ dàng được cài đặt lại mà không ảnh hưởng đến các chương trình đã cài đặt vì các tệp khởi động được lưu trữ an toàn trong phân vùng hệ thống. Phân vùng hệ thống được giữ riêng biệt với phần còn lại của các phân vùng lưu trữ các ứng dụng đã cài đặt.
   * Nếu bạn muốn sao lưu một tập hợp con dữ liệu nhất định, phân vùng mà nó được lưu trữ có thể được sao lưu thay vì toàn bộ ổ đĩa vật lý.
   * Các phân vùng giúp cho việc khôi phục dữ liệu trở nên thuận tiện và hiệu quả.
      
 ## Phân quyền với lệnh fdisk
 fdisk được khởi động bằng cách gõ thiết bị fdisk (với tư cách gốc) tại dấu nhắc lệnh. thiết bị có thể giống như / dev / hda hoặc / dev / sda (xem Phần 2.1.1). Các lệnh fdisk cơ bản bạn cần là:

|COMMAND| ACTION |
| :---- | :---- |
p | in bảng phân vùng
n | tạo một phân vùng mới
d | xóa một phân vùng
q | thoát mà không lưu các thay đổi
w | viết bảng phân vùng mới và thoát
# RAID
* RAID là chữ viết tắt của Redundant Array of Independent Disks. Ban đầu, RAID được sử dụng như một giải pháp phòng hộ vì nó cho phép ghi dữ liệu lên nhiều đĩa cứng cùng lúc. Về sau, RAID đã có nhiều biến thể cho phép không chỉ đảm bảo an toàn dữ liệu mà còn giúp gia tăng đáng kể tốc độ truy xuất dữ liệu từ đĩa cứng. Dưới đây là năm loại RAID được dùng phổ biến:

* Có thể hiểu nhanh về RAID qua thông tin dưới đây:
   * RAID chỉ nên làm việc với các loại ổ cứng dung lượng bằng nhau.
   * Sử dụng RAID sẽ tốn số lượng ổ nhiều hơn bình thường, nhưng đổi lại là dữ liệu sẽ an toàn hơn.
   * RAID có thể dùng cho bất kỳ hệ điều hành nào, Window, MAC OS X, Linux…vv
   * RAID 0 bằng tổng dung lượng các ổ cộng lại.
   * RAID 1 chỉ duy trì dung lượng 1 ổ.
   * RAID 5 sẽ có dung lượng ít hơn 1 ổ (5 ổ dùng raid 5 sẽ có dung lượng 4 ổ).
   * RAID 10 sẽ chỉ tạo được khi số ổ là chẵn, phải có tối thiểu từ ô ổ trở lên. Dung lượng bằng tổng số ổ chia đôi (10 ổ thì dung lượng sử dụng là 5 ổ).
   ## RAID 0
 ![image](https://user-images.githubusercontent.com/91528234/199191680-8cc51e6b-bcf1-4a2a-889f-402543bbdd9a.png)
 * Đây là dạng RAID đang được người dùng ưa thích do khả năng nâng cao hiệu suất trao đổi dữ liệu của đĩa cứng. Đòi hỏi tối thiểu hai đĩa cứng, RAID 0 cho phép máy tính ghi dữ liệu lên chúng theo một phương thức đặc biệt được gọi là Striping. Ví dụ bạn có 8 đoạn dữ liệu được đánh số từ 1 đến 8, các đoạn đánh số lẻ (1,3,5,7) sẽ được ghi lên đĩa cứng đầu tiên và các đoạn đánh số chẵn (2,4,6,8) sẽ được ghi lên đĩa thứ hai. Để đơn giản hơn, bạn có thể hình dung mình có 100MB dữ liệu và thay vì dồn 100MB vào một đĩa cứng duy nhất, RAID 0 sẽ giúp dồn 50MB vào mỗi đĩa cứng riêng giúp giảm một nửa thời gian làm việc theo lý thuyết. Từ đó bạn có thể dễ dàng suy ra nếu có 4, 8 hay nhiều đĩa cứng hơn nữa thì tốc độ sẽ càng cao hơn. Tuy nghe có vẻ hấp dẫn nhưng trên thực tế, RAID 0 vẫn ẩn chứa nguy cơ mất dữ liệu. Nguyên nhân chính lại nằm ở cách ghi thông tin xé lẻ vì như vậy dữ liệu không nằm hoàn toàn ở một đĩa cứng nào và mỗi khi cần truy xuất thông tin (ví dụ một file nào đó), máy tính sẽ phải tổng hợp từ các đĩa cứng. Nếu một đĩa cứng gặp trục trặc thì thông tin (file) đó coi như không thể đọc được và mất luôn. Thật may mắn là với công nghệ hiện đại, sản phẩm phần cứng khá bền nên những trường hợp mất dữ liệu như vậy xảy ra không nhiều.

* Có thể thấy RAID 0 thực sự thích hợp cho những người dùng cần truy cập nhanh khối lượng dữ liệu lớn, ví dụ các game thủ hoặc những người chuyên làm đồ hoạ, video số.
## RAID 1
![image](https://user-images.githubusercontent.com/91528234/199192151-75d0847a-aea0-44fd-b86c-c7ffa2534265.png)
* Đây là dạng RAID cơ bản nhất có khả năng đảm bảo an toàn dữ liệu. Cũng giống như RAID 0, RAID 1 đòi hỏi ít nhất hai đĩa cứng để làm việc. Dữ liệu được ghi vào 2 ổ giống hệt nhau (Mirroring). Trong trường hợp một ổ bị trục trặc, ổ còn lại sẽ tiếp tục hoạt động bình thường. Bạn có thể thay thế ổ đĩa bị hỏng mà không phải lo lắng đến vấn đề thông tin thất lạc. Đối với RAID 1, hiệu năng không phải là yếu tố hàng đầu nên chẳng có gì ngạc nhiên nếu nó không phải là lựa chọn số một cho những người say mê tốc độ. Tuy nhiên đối với những nhà quản trị mạng hoặc những ai phải quản lý nhiều thông tin quan trọng thì hệ thống RAID 1 là thứ không thể thiếu. Dung lượng cuối cùng của hệ thống RAID 1 bằng dung lượng của ổ đơn (hai ổ 80GB chạy RAID 1 sẽ cho hệ thống nhìn thấy duy nhất một ổ RAID 80GB).
# RAID 5
![image](https://user-images.githubusercontent.com/91528234/199192289-bdf767fa-7695-4924-bd37-0e6873c99226.png)
* y có lẽ là dạng RAID mạnh mẽ nhất cho người dùng văn phòng và gia đình với 3 hoặc 5 đĩa cứng riêng biệt. Dữ liệu và bản sao lưu được chia lên tất cả các ổ cứng. Nguyên tắc này khá rối rắm. Chúng ta quay trở lại ví dụ về 8 đoạn dữ liệu (1-8) và giờ đây là 3 ổ đĩa cứng. Đoạn dữ liệu số 1 và số 2 sẽ được ghi vào ổ đĩa 1 và 2 riêng rẽ, đoạn sao lưu của chúng được ghi vào ổ cứng 3. Đoạn số 3 và 4 được ghi vào ổ 1 và 3 với đoạn sao lưu tương ứng ghi vào ổ đĩa 2. Đoạn số 5, 6 ghi vào ổ đĩa 2 và 3, còn đoạn sao lưu được ghi vào ổ đĩa 1 và sau đó trình tự này lặp lại, đoạn số 7,8 được ghi vào ổ 1, 2 và đoạn sao lưu ghi vào ổ 3 như ban đầu. Như vậy RAID 5 vừa đảm bảo tốc độ có cải thiện, vừa giữ được tính an toàn cao. Dung lượng đĩa cứng cuối cùng bằng tổng dung lượng đĩa sử dụng trừ đi một ổ. Tức là nếu bạn dùng 3 ổ 80GB thì dung lượng cuối cùng sẽ là 160GB.
## RAID 10
*  bao giờ bạn ao ước một hệ thống lưu trữ nhanh nhẹn như RAID 0, an toàn như RAID 1 hay chưa? Chắc chắn là có và hiển nhiên ước muốn đó không chỉ của riêng bạn. Chính vì thế mà hệ thống RAID kết hợp 0+1 đã ra đời, tổng hợp ưu điểm của cả hai “đàn anh”. Tuy nhiên chi phí cho một hệ thống kiểu này khá đắt, bạn sẽ cần tối thiểu 4 đĩa cứng để chạy RAID 0+1. Dữ liệu sẽ được ghi đồng thời lên 4 đĩa cứng với 2 ổ dạng Striping tăng tốc và 2 ổ dạng Mirroring sao lưu. 4 ổ đĩa này phải giống hệt nhau và khi đưa vào hệ thống RAID 0+1, dung lượng cuối cùng sẽ bằng ½ tổng dung lượng 4 ổ, ví dụ bạn chạy 4 ổ 80GB thì lượng dữ liệu “thấy được” là (4*80)/2 = 160GB

## Lựa chọn theo nhu cầu
![image](https://user-images.githubusercontent.com/91528234/199192971-06133a58-1a9e-4411-8fe3-81c98f7fab81.png)

## Lệnh mdadm
* Tiện ích mdadm có thể được sử dụng để tạo và quản lý các mảng lưu trữ bằng khả năng RAID phần mềm của Linux. Quản trị viên có khả năng linh hoạt cao trong việc phối hợp các thiết bị lưu trữ riêng lẻ của họ và tạo ra các thiết bị lưu trữ hợp lý có hiệu suất cao hơn hoặc các đặc điểm dự phòng.
### VD về tạo RAID0 trên CentOS 7
#### Bước 1: Cập nhật hệ thống và cài đặt mdadm để quản lý RAID

Để thiết lập RAID0 trên hệ điều hành Linux chúng ta cần thực hiện cập nhật (update) hệ thống và cài đặt gói `mdadm`.

#### Bước 2: Kiểm tra thông tin ổ đĩa trên máy:

* Trước khi tạo RAID0, cần đảm bảo có ít nhất hai ổ đĩa cứng chạy lệnh sau để kiểm tra:
```
[root@localhost ~]# fdisk -l |grep sd
Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200    41943039    19921920   8e  Linux LVM
Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors
Disk /dev/sdc: 10.7 GB, 10737418240 bytes, 20971520 sectors
```
* Qua lệnh kiểm tra trên chúng ta thấy có 2 đĩa cứng mới được phát hiện, bây giờ chúng ta thực hiện kiểm tra xem các ổ cứng có sử dụng RAID nào chưa bằng lệnh mdadm cùng với tùy chọn --examine như bên dưới.
```
[root@localhost ~]# mdadm --examine /dev/sd[b-c]
mdadm: No md superblock detected on /dev/sdb.
mdadm: No md superblock detected on /dev/sdc.
```

* Kết trên trả về cho chúng ta biết rằng không có RAID nào được áp dụng cho hai ổ sdb và sdc.

#### Bước 3: Tạo phân vùng đĩa cứng

* Thực hiện tạo phân vùng trên đĩa có tên là sdb và sdc cho RAID bằng lệnh fdisk.

 **Tạo phân vùng trên ổ đĩa sdb**.

* Chạy lệnh fdisk /dev/sdb để tạo phân vùng cho sdb và thực hiện các thao tác sau:

   * Nhấn n để tạo phân vùng mới.
   * Sau đó chọn p cho phân vùng chính.
   * Tiếp theo chọn số phân vùng là 1 .
   * Nhập giá trị ban đầu, giá trị kết thúc và nhấn phím Enter.
   * Tiếp theo nhấn p để in phân vùng đã được tạo.
* Thực hiện các bước sau đây để tạo Linux RAID tự động trên các phân vùng:
   * Nhấn L để liệt kê tất cả các loại có sẵn.
   * Nhập t để chọn phân vùng.
   * Nhập fd để chọn Linux RAID tự động và nhấn Enter để áp dụng.
   * Sử dụng phím p để in những thay đổi.
   * Cuối cùng chúng ta nhấn phím w lưu các thay đổi.
* Các thao tác trên được thực hiện như sau:
```
[root@localhost ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xd1c9ae6a.

Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-20971519, default 2048): 2048
Last sector, +sectors or +size{K,M,G} (2048-20971519, default 20971519): 20971519
Partition 1 of type Linux and of size 10 GiB is set

Command (m for help): p

Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xd1c9ae6a

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    20971519    10484736   83  Linux

Command (m for help): L

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris
 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux extended  c7  Syrinx
 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data
 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility
 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt
 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access
 a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT
 f  W95 Ext'd (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor
12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor
14  Hidden FAT16 <3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary
16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS
17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE
18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep
1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT
1e  Hidden W95 FAT1 80  Old Minix

Command (m for help): t
Selected partition 1
Hex code (type L to list all codes): fd
Changed type of partition 'Linux' to 'Linux raid autodetect'

Command (m for help): p

Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xd1c9ae6a

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    20971519    10484736   fd  Linux raid autodetect

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
```

* Tương tự như vậy chúng ta tạo phân vùng cho `sdc`.

* Sau khi tạo xong chúng ta chạy lệnh bên dưới kiểm tra xem phân vùng được tạo hay chưa.
```
[root@localhost ~]# fdisk -l | grep sd
Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200    41943039    19921920   8e  Linux LVM
Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors
/dev/sdb1            2048    20971519    10484736   fd  Linux raid autodetect
Disk /dev/sdc: 10.7 GB, 10737418240 bytes, 20971520 sectors
/dev/sdc1            2048    20971519    10484736   fd  Linux raid autodetect
```

* Tiếp theo chúng ta chạy lệnh bên dưới để kiểm tra xem các đĩa hiện có tham gia RAID nào không:
* 
```
[root@localhost ~]#  mdadm --examine /dev/sd[b-c]
/dev/sdb:
   MBR Magic : aa55
Partition[0] :     20969472 sectors at         2048 (type fd)
/dev/sdc:
   MBR Magic : aa55
Partition[0] :     20969472 sectors at         2048 (type fd)
[root@localhost ~]#  mdadm --examine /dev/sd[b-c]1
mdadm: No md superblock detected on /dev/sdb1.
mdadm: No md superblock detected on /dev/sdc1.
```
#### Bước 4: Tạo RAID0

* Chúng ta chạy lệnh sau để tạo RAID0:

```
[root@localhost ~]# mdadm -C /dev/md0 -l raid0 -n 2 /dev/sd[b-c]1
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
```
* Trong đó:

   * C: Tạo RAID mới.
   * l: Level của RAID.
   * n: Không có thiết bị RAID.
* Ngoài ra lệnh tạo RAID0 sau đây cũng có ý nghĩa như lệnh chúng ta vừa chạy:
```
mdadm --create /dev/md0 --level=stripe --raid-devices=2 /dev/sd[b-c]1
```

* Kiểm tra lại RAID vừa tạo bằng các cách sau:

```
[root@localhost ~]# cat /proc/mdstat
Personalities : [raid0]
md0 : active raid0 sdc1[1] sdb1[0]
      20951040 blocks super 1.2 512k chunks

unused devices: <none>
```

* Qua kết quả trên cho chúng ta thấy RAID0 đã được tạo với hai phân vùng `sdb1` và `sdc1`. Chúng ta cũng có thể kiểm tra bằng lệnh bên dưới:

```
[root@localhost ~]# mdadm -E /dev/sd[b-c]1
/dev/sdb1:
          Magic : a92b4efc
        Version : 1.2
    Feature Map : 0x0
     Array UUID : 98cffedb:dd23fd6d:07b60209:b92643bd
           Name : localhost.localdomain:0  (local to host localhost.localdomain)
  Creation Time : Sun May 19 11:40:09 2019
     Raid Level : raid0
   Raid Devices : 2

 Avail Dev Size : 20951040 (9.99 GiB 10.73 GB)
    Data Offset : 18432 sectors
   Super Offset : 8 sectors
   Unused Space : before=18352 sectors, after=0 sectors
          State : clean
    Device UUID : fedf81e4:0cea1e46:3f96f2c1:9c4fa897

    Update Time : Sun May 19 11:40:09 2019
  Bad Block Log : 512 entries available at offset 8 sectors
       Checksum : af1ccef - correct
         Events : 0

     Chunk Size : 512K

   Device Role : Active device 0
   Array State : AA ('A' == active, '.' == missing, 'R' == replacing)
/dev/sdc1:
          Magic : a92b4efc
        Version : 1.2
    Feature Map : 0x0
     Array UUID : 98cffedb:dd23fd6d:07b60209:b92643bd
           Name : localhost.localdomain:0  (local to host localhost.localdomain)
  Creation Time : Sun May 19 11:40:09 2019
     Raid Level : raid0
   Raid Devices : 2

 Avail Dev Size : 20951040 (9.99 GiB 10.73 GB)
    Data Offset : 18432 sectors
   Super Offset : 8 sectors
   Unused Space : before=18352 sectors, after=0 sectors
          State : clean
    Device UUID : 7abd085c:5144fc8f:5a200101:4a70369c

    Update Time : Sun May 19 11:40:09 2019
  Bad Block Log : 512 entries available at offset 8 sectors
       Checksum : ff2af79 - correct
         Events : 0

     Chunk Size : 512K

   Device Role : Active device 1
   Array State : AA ('A' == active, '.' == missing, 'R' == replacing)
   ```
   
* Hoặc có thể chạy lệnh sau để kiểm tra:

```
[root@localhost ~]# mdadm --detail /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Sun May 19 11:40:09 2019
        Raid Level : raid0
        Array Size : 20951040 (19.98 GiB 21.45 GB)
      Raid Devices : 2
     Total Devices : 2
       Persistence : Superblock is persistent

       Update Time : Sun May 19 11:40:09 2019
             State : clean
    Active Devices : 2
   Working Devices : 2
    Failed Devices : 0
     Spare Devices : 0

        Chunk Size : 512K

Consistency Policy : none

              Name : localhost.localdomain:0  (local to host localhost.localdomain)
              UUID : 98cffedb:dd23fd6d:07b60209:b92643bd
            Events : 0

    Number   Major   Minor   RaidDevice State
       0       8       17        0      active sync   /dev/sdb1
       1       8       33        1      active sync   /dev/sdc1
```
       
       
#### Bước 5: Tạo file system (ext4) cho thiết bị RAID /dev/md0

```
[root@localhost ~]#  mkfs.ext4 /dev/md0
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=128 blocks, Stripe width=256 blocks
1310720 inodes, 5237760 blocks
261888 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=2153775104
160 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
	4096000

Allocating group tables: done
Writing inode tables: done
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done
```

* Tiếp theo tạo thư mục gắn kết `raid0` để gắn thiết bị `/dev/md0` thực hiện như bên dưới.

```
[root@localhost ~]# mkdir raid0
[root@localhost ~]# mount /dev/md0 raid0/
```

* Tiếp theo, chạy lệnh `df` để kiểm tra xem thiết bị `/dev/md0` được gắn trong thư mục `/root/raid0` không.

```
[root@localhost ~]# df -h
Filesystem           Size  Used Avail Use% Mounted on
/dev/mapper/cl-root   17G  1.3G   16G   8% /
devtmpfs             475M     0  475M   0% /dev
tmpfs                487M     0  487M   0% /dev/shm
tmpfs                487M  7.7M  479M   2% /run
tmpfs                487M     0  487M   0% /sys/fs/cgroup
/dev/sda1           1014M  201M  814M  20% /boot
tmpfs                 98M     0   98M   0% /run/user/0
/dev/md0             9.8G   37M  9.2G   1% /root/raid0
```

* Tạo một tệp `raid0/test0.txt`, thêm nội dung vào tệp đã tạo và xem nội dung của tệp.

```
[root@localhost ~]# ls -l raid0/
total 20
drwx------. 2 root root 16384 May 19 13:36 lost+found
[root@localhost ~]# echo "This is RAID0" > raid0/test0.txt
[root@localhost ~]# cat raid0/test0.txt
This is RAID0
```
Thiết bị `/dev/md0` gắn kết của chúng ta là tạm thời. Nếu hệ điều hành được khởi động lại, các thư mục được gắn kết này sẽ bị mất. Vì vậy, chúng ta cần phải gắn kết vĩnh viễn. Để thực hiện gắn kết vĩnh viễn phải nhập trong tệp `/etc/fstab`. Bạn có thể sử dụng trình soạn thảo vi để nhập dòng bên dưới vào:

```
/dev/md0        raid0   ext4    defaults        0 0
```

* Thực hiện như sau:

```
[root@localhost ~]# vi /etc/fstab

#
# /etc/fstab
# Created by anaconda on Tue May 14 10:34:53 2019
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/cl-root     /                       xfs     defaults        0 0
UUID=58253f4e-01e2-47c8-8f0c-49a1e5b0b7bf /boot                   xfs     defaults        0 0
/dev/mapper/cl-swap     swap                    swap    defaults        0 0
/dev/md0        raid0   ext4    defaults        0 0
```

* Lưu lại file /etc/fstab và chạy lệnh:

```
[root@localhost ~]# mount -a
[root@localhost ~]# mount -av
/                        : ignored
/boot                    : already mounted
swap                     : ignored
raid0                    : already mounted
```

Nếu có lỗi, không reboot server để tránh tình trạng server không thể khởi động. Kiểm tra cấu hình trong file `/etc/fstab` và chạy lại lệnh cho tới khi không có thông báo lỗi.

#### Bước 6: Lưu cấu hình RAID

Lưu cấu hình RAID vào một tệp để giữ cấu hình để sử dụng trong tương lai.

Chúng ta sử dụng lệnh `mdadm` với các tùy chọn `-s`(quét) và `-v` (dài dòng) như sau:

```
[root@localhost ~]# mdadm -E -s -v >> /etc/mdadm.conf
[root@localhost ~]# cat /etc/mdadm.conf
ARRAY /dev/md/0  level=raid0 metadata=1.2 num-devices=2 UUID=98cffedb:dd23fd6d:07b60209:b92643bd name=localhost.localdomain:0
   devices=/dev/sdc1,/dev/sdb1
```

* Qua các bước trên chúng ta đã tạo thành công RAID0 trên Centos
