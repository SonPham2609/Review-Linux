# Linux File System
* Hệ thống tệp (file) Linux là một tập hợp có cấu trúc các tệp trên ổ đĩa hoặc một phân vùng. Phân vùng là một phân đoạn bộ nhớ và chứa một số dữ liệu cụ thể. Trong máy của chúng ta, có thể có nhiều phân vùng bộ nhớ khác nhau. Nói chung, mọi phân vùng đều chứa một hệ thống tệp.
* Hệ thống máy tính đa năng cần lưu trữ dữ liệu một cách có hệ thống để chúng ta có thể dễ dàng truy cập các tệp trong thời gian ngắn hơn. Nó lưu trữ dữ liệu trên đĩa cứng (HDD) hoặc một số loại lưu trữ tương đương. Có thể có những lý do dưới đây để duy trì hệ thống tệp:

    * Chủ yếu máy tính lưu dữ liệu vào bộ nhớ RAM; nó có thể mất dữ liệu nếu nó bị tắt. Tuy nhiên, có sẵn RAM bất biến (RAM Flash và SSD) để duy trì dữ liệu sau khi ngắt nguồn.

    * Việc lưu trữ dữ liệu được ưu tiên trên ổ cứng so với RAM tiêu chuẩn vì RAM tốn nhiều dung lượng hơn dung lượng đĩa. Chi phí đĩa cứng đang giảm dần so với RAM.
* Hệ thống tệp Linux chứa các phần sau:

    * Thư mục gốc (/)

    * Định dạng lưu trữ dữ liệu cụ thể (EXT3, EXT4, BTRFS, XFS, v.v.)

    * Một phân vùng hoặc ổ đĩa hợp lý có một hệ thống tệp cụ thể.
## Cấu trúc hệ thống tệp Linux
* Hệ thống tệp Linux có cấu trúc tệp phân cấp vì nó chứa thư mục gốc và các thư mục con của nó.ất cả các thư mục khác có thể được truy cập từ thư mục gốc. Một phân vùng thường chỉ có một hệ thống tệp, nhưng nó có thể có nhiều hơn một hệ thống tệp.

*  Hệ thống tệp được thiết kế theo cách để nó có thể quản lý và cung cấp không gian cho dữ liệu lưu trữ không thay đổi. Tất cả các hệ thống tệp đều yêu cầu một không gian tên là phương pháp đặt tên và tổ chức. Không gian tên xác định quy trình đặt tên, độ dài của tên tệp hoặc một tập hợp con các ký tự có thể được sử dụng cho tên tệp. Nó cũng xác định cấu trúc logic của các tệp trên một phân đoạn bộ nhớ, chẳng hạn như việc sử dụng các thư mục để tổ chức các tệp cụ thể. Khi không gian tên được mô tả, mô tả Siêu dữ liệu phải được xác định cho tệp cụ thể đó.

* Cấu trúc dữ liệu cần hỗ trợ cấu trúc thư mục phân cấp; cấu trúc này được sử dụng để mô tả không gian đĩa có sẵn và được sử dụng cho một khối cụ thể. Nó cũng có các chi tiết khác về tệp như kích thước tệp, ngày và giờ tạo, cập nhật và sửa đổi lần cuối.
* Ngoài ra, nó lưu trữ thông tin nâng cao về phần của đĩa, chẳng hạn như phân vùng và ổ đĩa.

* Dữ liệu nâng cao và cấu trúc mà nó đại diện chứa thông tin về hệ thống tệp được lưu trữ trên ổ đĩa; nó khác biệt và độc lập với siêu dữ liệu hệ thống tệp.

* Hệ thống tệp Linux chứa kiến ​​trúc triển khai phần mềm hệ thống tệp gồm hai phần. Hãy xem xét hình ảnh dưới đây:

![image](https://user-images.githubusercontent.com/91528234/199150030-927ce7b2-c770-48e8-86f5-70b0e92f6eeb.png)

* Hệ thống tệp yêu cầu một API (Giao diện lập trình ứng dụng) để truy cập các lệnh gọi hàm để tương tác với các thành phần của hệ thống tệp như tệp và thư mục. API hỗ trợ các tác vụ như tạo, xóa và sao chép tệp. Nó tạo điều kiện cho một thuật toán xác định sự sắp xếp của các tệp trên một hệ thống tệp.

* Hai phần đầu tiên của hệ thống tệp nhất định được gọi là hệ thống tệp ảo Linux. Nó cung cấp một bộ lệnh duy nhất để hạt nhân và các nhà phát triển truy cập vào hệ thống tệp. Hệ thống tệp ảo này yêu cầu trình điều khiển hệ thống cụ thể cung cấp giao diện cho hệ thống tệp.
## Các tính năng của hệ thống tệp Linux
* Trong Linux, hệ thống tệp tạo ra một cấu trúc cây. Tất cả các tệp được sắp xếp như một cái cây và các nhánh của nó. Thư mục trên cùng được gọi là thư mục gốc (/). Tất cả các thư mục khác trong Linux có thể được truy cập từ thư mục gốc.

* Một số tính năng chính của hệ thống tệp Linux như sau:

    * **Chỉ định đường dẫn**: Sử dụng dấu gạch chéo (/) để chia các thành phần. Dữ liệu sẽ được lưu trữ trong /home/MyDocument/Work.

    * **Phân vùng, Thư mục và Ổ đĩa**: Linux không sử dụng ký tự ổ đĩa để tổ chức ổ đĩa như Windows. Trong Linux,  không thể biết liệu chúng đang định địa chỉ một phân vùng, một thiết bị mạng hay một thư mục "thông thường" và một Ổ đĩa.

    * **Phân biệt chữ hoa chữ thường**: Hệ thống tệp Linux phân biệt chữ hoa chữ thường. Nó phân biệt giữa tên tệp viết thường và viết hoa. Chẳng hạn, có sự khác biệt giữa test.txt và Test.txt trong Linux. Quy tắc này cũng được áp dụng cho các thư mục và lệnh Linux.

    * **Phần mở rộng tệp**: Trong Linux, tệp có thể có phần mở rộng là '.txt', nhưng không nhất thiết tệp phải có phần mở rộng tệp. Trong khi làm việc với Shell, nó tạo ra một số vấn đề cho người mới bắt đầu để phân biệt giữa các tệp và thư mục. Nếu chúng ta sử dụng trình quản lý tệp đồ họa, nó tượng trưng cho các tệp và thư mục.

    * **Tệp ẩn**: Linux phân biệt giữa tệp tiêu chuẩn và tệp ẩn, hầu hết các tệp cấu hình được ẩn trong Hệ điều hành Linux. Thông thường, chúng ta không cần truy cập hoặc đọc các tệp ẩn. Các tệp ẩn trong Linux được biểu thị bằng dấu chấm (.) Trước tên tệp (ví dụ: .ignore). Để truy cập các tệp, chúng ta cần thay đổi chế độ xem trong trình quản lý tệp hoặc cần sử dụng một lệnh cụ thể trong trình bao.
 ## Các loại hệ thống tệp Linux
 * Khi chúng ta cài đặt hệ điều hành Linux, Linux cung cấp nhiều hệ thống tệp như Ext, Ext2, Ext3, Ext4, JFS, ReiserFS, XFS, btrfs và swap.
 ![image](https://user-images.githubusercontent.com/91528234/199150947-0ed029a9-49bb-4fbd-b38b-541b2e71dd5f.png)
 ### Ext, Ext2, Ext3 and Ext4 file system
 * Hệ thống tập tin Ext là viết tắt của **Extended File System**. Nó chủ yếu được phát triển cho **MINIX OS**. Hệ thống tệp Ext là phiên bản cũ hơn và không còn được sử dụng do một số hạn chế.

* **Ext2** là hệ thống tệp Linux đầu tiên cho phép quản lý hai terabyte dữ liệu. Ext3 được phát triển thông qua Ext2; nó là phiên bản nâng cấp của Ext2 và có khả năng tương thích ngược. Hạn chế lớn của Ext3 là không hỗ trợ máy chủ vì hệ thống tệp này không hỗ trợ khôi phục tệp và ảnh chụp nhanh đĩa.

* Hệ thống tệp **Ext4** là hệ thống tệp nhanh hơn trong số tất cả các hệ thống tệp Ext. Đây là một tùy chọn rất tương thích cho các đĩa SSD (ổ thể rắn) và nó là hệ thống tệp mặc định trong bản phân phối Linux.
### JFS File System
* **JFS** là viết tắt của **Journaled File System**, và nó được **IBM phát triển cho AIX Unix**. Nó là một thay thế cho hệ thống tệp Ext. Nó cũng có thể được sử dụng thay cho Ext4, nơi cần sự ổn định với ít tài nguyên. Nó là một hệ thống tệp tiện dụng khi sức mạnh của CPU bị hạn chế.

### Hệ thống tệp ReiserFS

**ReiserFS** là một giải pháp thay thế cho hệ thống tệp Ext3. Nó đã được cải thiện hiệu suất và các tính năng nâng cao. Trong thời gian trước đó, ReiserFS được sử dụng làm hệ thống tệp mặc định trong SUSE Linux, nhưng sau đó nó đã thay đổi một số chính sách nên SUSE quay trở lại Ext3. Hệ thống tệp này hỗ trợ động phần mở rộng tệp, nhưng nó có một số hạn chế về hiệu suất.


### Hệ thống tệp XFS

* Hệ thống tệp **XFS** được coi là JFS tốc độ cao, được phát triển để xử lý I/O song song. NASA vẫn đang sử dụng hệ thống tệp này với máy chủ lưu trữ cao (máy chủ 300+ Terabyte).

### Hệ thống tệp Btrfs

* **Btrfs** là viết tắt của hệ thống tệp B cây. Nó được sử dụng để chịu lỗi, sửa chữa hệ thống, quản trị vui vẻ, cấu hình lưu trữ mở rộng và hơn thế nữa. Nó không phải là một phù hợp tốt cho hệ thống sản xuất.

### Hoán đổi hệ thống tệp

Hệ thống tệp hoán đổi được sử dụng để phân trang bộ nhớ trong hệ điều hành Linux trong chế độ ngủ đông của hệ thống. Một hệ thống không bao giờ ở trạng thái ngủ đông bắt buộc phải có không gian hoán đổi bằng với kích thước RAM của nó.

# Lệnh Fsck trong linux (sửa chữa hệ thống tập tin)
* fsck (kiểm tra hệ thống tệp) là một tiện ích dòng lệnh cho phép bạn thực hiện kiểm tra tính nhất quán và sửa chữa tương tác trên một hoặc nhiều hệ thống tệp Linux. Nó sử dụng các chương trình dành riêng cho loại hệ thống tập tin mà nó kiểm tra.
## Cách sử dụng fsck
Lệnh fsck có dạng chung sau:
```
fsck
```
* Chỉ người dùng root hoặc người dùng có quyền sudo có thể xóa bộ đệm.

* Khi không có `FILESYSTEM` nào được cung cấp làm đối số, fsck kiểm tra các thiết bị được liệt kê trong tệp fstab .

* Không bao giờ chạy fsck trên các phân vùng được gắn vì nó có thể làm hỏng hệ thống tệp. Trước khi thử kiểm tra hoặc sửa chữa các hệ thống tập tin luôn `unmount` nó trước.

* Lệnh fsck là một trình bao bọc cho các trình kiểm tra hệ thống tệp Linux khác nhau ( fsck.* ) Và chấp nhận các tùy chọn khác nhau tùy thuộc vào loại hệ thống tệp.

Kiểm tra các trang hướng dẫn để biết thêm thông tin về một trình kiểm tra cụ thể. Ví dụ: để xem các tùy chọn khả dụng cho fsck.ext4 , hãy nhập:
```
man fsck.ext4
```
## Khi nào thì dùng fsck trong Linux
* Có nhiều tình huống khác nhau khi bạn muốn chạy fsck. Dưới đây là một số ví dụ:

* Hệ thống không khởi động được.

* Các tệp trên hệ thống bị hỏng (thường thì bạn có thể thấy lỗi đầu vào/đầu ra).

* Ổ đĩa đính kèm (bao gồm ổ đĩa flash/thẻ SD) không hoạt động như mong đợi.
## Các tùy chọn có sẵn của fsck
* Lệnh Fsck cần được chạy với các đặc quyền của superuser hoặc **root**. Bạn có thể sử dụng nó với các đối số khác nhau. Việc sử dụng chúng tùy thuộc vào trường hợp cụ thể của bạn. Dưới đây, bạn sẽ thấy một số tùy chọn quan trọng hơn:

|COMMAND| ACTION |
| :---- | :---- |
-A | - Được sử dụng để kiểm tra tất cả các hệ thống tập tin. Danh sách được lấy từ / etc / fstab.
-C | - Hiển thị thanh tiến trình.
-l | - Khóa thiết bị để đảm bảo không có chương trình nào khác cố gắng sử dụng phân vùng trong quá trình kiểm tra.
-M | - Không kiểm tra hệ thống tập tin được gắn kết.
-N | - Chỉ hiển thị những gì sẽ được thực hiện - không có thay đổi thực tế nào được thực hiện.
-P | - Nếu bạn muốn kiểm tra song song các hệ thống tập tin, bao gồm cả root.
-R | - Không kiểm tra hệ thống tập tin gốc. Điều này chỉ hữu ích với ‘-A‘.
-r | - Cung cấp số liệu thống kê cho từng thiết bị đang được kiểm tra.
-T | - Không hiển thị tiêu đề.
-t | - Chỉ định riêng các loại hệ thống tệp được kiểm tra. Các loại có thể là danh sách được phân tách bằng dấu phẩy.
-V | - Cung cấp mô tả những gì đang được thực hiện.
## Cách chạy fsck để sửa lỗi hệ thống tệp Linux
* Trường hợp sử dụng đơn giản nhất của lệnh fsck là sửa chữa một hệ thống tệp ext3 hoặc ext4 không root bị hỏng.

* Ngắt kết nối thiết bị:
```
sudo umount /dev/sda1
```
Chạy fsck để sửa chữa hệ thống tập tin:
```
sudo fsck -p /dev/sda1
```
Tùy chọn `-p` yêu cầu fsck tự động sửa chữa mọi sự cố có thể được khắc phục một cách an toàn mà không cần sự can thiệp của người dùng.

Khi hệ thống tập tin được sửa chữa, gắn kết phân vùng:
```
sudo mount /dev/sda1
```
# Monitoring Disk
## Lệnh df
* Lệnh “df” viết tắt của “disk filesystem“, nó được dùng để lấy toàn bộ thông tin về lượng ổ cứng khả dụng và lượng ổ cứng đã dùng của các file hệ thống trên linux. Cách đơn giản nhất để kiểm tra dung lượng đĩa là ta sử dụng lệnh `df`:

![image](https://user-images.githubusercontent.com/91528234/199157000-dbc89421-d653-4972-9431-1500436c6898.png)

* Trong đó:

   * filesystem: tên filesystem có thể trùng với phân vùng đĩa.
   * 1K-blocks: Số lượng khối (block) có trong filesystem có kích thước 1Kb.
   * Used: Số lượng 1K-block được sử dụng trong filesystem.
   * Available: Số lượng 1K-block đang có sẵn.
   * Use%: Phần trăm đĩa đã sử dụng trong filesystem.
   * Mounted on: Nơi mount.
* Lệnh `df` được đi kèm với một số tùy chọn để hiển thị nội dung rõ ràng và thân thiện với người dùng hơn.
Tùy chọn `-h` cho ta một cái nhìn trực quan hơn khi đọc các thông số ở chế độ chi tiết : bytes, megabytes và gigabytes.

![image](https://user-images.githubusercontent.com/91528234/199157332-6daa82b5-b3ef-4f01-8993-e8cba2c45b42.png)
## Kiểm tra dung lượng đĩa với các trường hợp cụ thể
* Để kiểm tra space của một đĩa/phân vùng cụ thể, bạn sử dụng lệnh df với cú pháp:
```
df <option> path
```
* Một số ví dụ:
     * Kiểm tra dung lượng ổ đĩa phân vùng
     ![image](https://user-images.githubusercontent.com/91528234/199157667-92a505ad-f319-445a-abce-472026e42db6.png)
* Bạn có thể cờ `output` đi kèm lệnh df:
```
df -h --output='field1', 'field2' /
```
      Kiểm tra kích thước và phần trăm đĩa đã sử dụng, ta gõ lệnh:
      ![image](https://user-images.githubusercontent.com/91528234/199157947-dd02236c-d3c5-4e2f-919f-cf5f735ac495.png)
## Lệnh du
* du là một công cụ dòng lệnh được cung cấp bởi Linux, nhằm báo cáo dung lượng ổ đĩa được sử dụng bởi các thư mục và **file.du** là viết tắt của từ “disk usage”. Đây là công cụ chính để phân tích không gian ổ đĩa trong dòng lệnh.
```
du <option> <path|file>
du <option> <path1> <path2> <path3>  
```
* Kiểm tra dung lượng của một file cụ thể
Ví dụ để kiểm tra kích thước của một file .bashrc, bạn có thể chạy lệnh:
![image](https://user-images.githubusercontent.com/91528234/199158729-4e8d56f6-ada1-49a2-8fef-75e0cef44589.png)
## Kiểm tra dung lượng đĩa đã sử dụng cho các thư mục
* Bạn có thể kiểm tra dung lượng đĩa được sử dụng cho thư mục bằng lệnh du với tên đường dẫn cụ thể. Tuy nhiên trong một vài trường hợp bạn không muốn nhìn thấy output của tất cả file hoặc thư mục riêng lẻ, bạn có thể sử dụng tùy chọn `-shc`. Ví dụ dưới đây, tôi muốn kiểm tra dung lượng đĩa đã sử dụng cho thư mục /home hoặc /var/log.
![image](https://user-images.githubusercontent.com/91528234/199159211-4b39670c-9169-463c-8549-bbd019cc67c7.png)
* Ý nghĩa của các tùy chọn:

   * `-s`: dùng để tóm tắt, nó sẽ hiển thị tổng số đường dẫn được cung cấp thay vì hiển thị danh sách tất cả các tệp và thư mục.
   * `-h`: để con người có thể đọc được, nó sẽ hiển thị kết quả với các đơn vị.
   * `-c`: đối với tổng số lớn, nếu bạn chỉ định nhiều đường dẫn, nó sẽ tổng hợp chúng để tạo ra tổng số lớn cho chúng.
   # Tạo file Systems
   
* Lệnh mkfs xây dựng hệ thống tệp trên thiết bị khối:
```
# mkfs [option] device
```
* mkfs là giao diện người dùng cho các tiện ích trình tạo trong /sbin chẳng hạn như **mkfs.ext4**. Bạn có thể sử dụng lệnh mkfs với tùy chọn `-t` fstype hoặc tiện ích trình tạo để chỉ định loại hệ thống tệp cần xây dựng. Ví dụ: các lệnh sau là các cách tương đương để tạo hệ thống tệp ext4 với nhãn Dự án trên thiết bị /dev/sdb1:
```
# mkfs -t ext4 -L Projects /dev/sdb1
# mkfs.ext4 -L Projects /dev/sdb1
```
* và xem file đã được khởi tạo chưa với lệnh
```
lsblk
```
# Mounting and Unmounting Filesystems
* Để truy cập nội dung của hệ thống tệp, bạn phải gắn thiết bị khối của nó vào một điểm gắn kết trong hệ thống phân cấp thư mục. Bạn có thể sử dụng lệnh mkdir để tạo một thư mục để sử dụng làm điểm gắn kết, ví dụ:
```
# mkdir /var/project
```

* Bạn có thể sử dụng một thư mục hiện có làm điểm gắn kết, nhưng nội dung của nó sẽ bị ẩn cho đến khi bạn ngắt kết nối hệ thống tệp cơ bản.

* Lệnh mount sẽ gắn thiết bị chứa hệ thống tệp vào điểm mount:
```
# mount [options] device mount_point 
```

* Bạn có thể chỉ định thiết bị theo tên, UUID hoặc nhãn của nó. Ví dụ: các lệnh sau là các cách tương đương để gắn hệ thống tệp trên thiết bị khối /dev/sdb1:
```
# mount /dev/sdb1/var/project
# mount LABEL = "projects" /var/project
```

* Nếu bạn không chỉ định bất kỳ đối số nào, mount sẽ hiển thị tất cả các hệ thống tệp mà hệ thống hiện đã gắn kết, ví dụ:
```
# mout
/dev/mapper/vg_host01-lv_root on / type ext4 (rw)
...
```
* Trong ví dụ này, LVM logic volume/dev/mapper/ vg_host01-lv_root được gắn trên /. Loại hệ thống tệp là ext4 và được gắn cho cả việc đọc và ghi. (Bạn cũng có thể sử dụng lệnh cat /proc/mounts để hiển thị thông tin về hệ thống tệp được gắn kết.)

Lệnh df hiển thị thông tin về không gian còn lại trong nhà trên các hệ thống tệp được gắn kết, ví dụ:
```
# df -h
```
Filesystem                     Size  Used Avail Use% Mounted on
/dev/mapper/vg_host01-lv_root  36G   12G   22G  36% /
...
```
* Bạn có thể sử dụng tùy chọn -B (bind) cho lệnh mount để gắn thiết bị khối tại nhiều điểm mount. Bạn cũng có thể đếm lại một phần của hệ thống phân cấp thư mục, không cần phải là một hệ thống tệp hoàn chỉnh, ở một nơi khác. Ví dụ, lệnh sau mounts /var/project/project1 on/mnt:
```
# mount -B /var/projects/project1 /mnt
```
* Mỗi hệ thống phân cấp thư mục hoạt động như một bản sao của hệ thống phân cấp khác. Các tệp giống nhau đều có thể truy cập được ở cả hai vị trí, mặc dù bất kỳ số lượng con nào không được sao chép. Những gương này không cung cấp dự phòng dữ liệu.

* Bạn cũng có thể gắn kết một tệp trên một tệp khác, ví dụ:
```
# touch /mnt/foo

# mount -B /etc/hosts/mnt/foo
```
* Trong ví dụ này, /etc/hosts và /mnt/foo đại diện cho cùng một tệp. Không thể truy cập tệp hiện có hoạt động như một điểm gắn kết cho đến khi bạn ngắt kết nối tệp bên trên.

Tùy chọn `-B` không đính kèm đệ quy bất kỳ tài khoản con nào bên dưới hệ thống phân cấp thư mục. Để bao gồm các số lượng con trong nhân bản, hãy sử dụng tùy chọn `-R` (liên kết đệ quy) để thay thế.

Khi bạn sử dụng `-B` hoặc `-R`, các tùy chọn gắn kết hệ thống tệp vẫn giống như các tùy chọn cho điểm gắn kết ban đầu. Để sửa đổi các tùy chọn gắn kết, hãy sử dụng một lệnh remount riêng, ví dụ:
```
# mount -o remount,ro /mnt/foo
```
* Để ngắt kết nối hệ thống tệp, hãy sử dụng lệnh umount, ví dụ:
```
# umount /var/project
```
# Partitioning Disks( Phân vùn ổ đĩa)
* Phân vùng đĩa là quá trình chia đĩa thành một hoặc nhiều vùng được gọi là phân vùng. Bảng phân vùng nằm trong khu vực đầu tiên của đĩa và lưu trữ thông tin về kích thước và vị trí của các phân vùng đã tạo. Nói cách khác, phân vùng đĩa cho phép chia một ổ đĩa vật lý thành các ổ đĩa logic nhỏ hơn được gọi là ổ đĩa. Đối với một hệ điều hành, các ổ đĩa này hoàn toàn riêng biệt, vì vậy bạn có thể thực hiện các thao tác trên một ổ đĩa mà không ảnh hưởng đến các ổ đĩa khác.

* Hầu hết người dùng sẽ không bao giờ gặp phải nhu cầu phân vùng đĩa, nhưng phân vùng đĩa có thể hữu ích trong một số trường hợp.

   * Một ổ cứng mới thực tế không thể sử dụng được trừ khi nó được phân vùng để lưu dữ liệu.

   * Các phân vùng có thể được sử dụng để tổ chức dữ liệu theo kiểu của chúng. Ví dụ: bạn có thể có một phân vùng lưu trữ tất cả các tài liệu của bạn và một phân vùng khác lưu trữ tất cả các tệp nhạc của bạn.

   * Windows có thể dễ dàng được cài đặt lại mà không ảnh hưởng đến các chương trình đã cài đặt vì các tệp khởi động được lưu trữ an toàn trong phân vùng hệ thống. Phân vùng hệ thống được giữ riêng biệt với phần còn lại của các phân vùng lưu trữ các ứng dụng đã cài đặt.
   * Nếu bạn muốn sao lưu một tập hợp con dữ liệu nhất định, phân vùng mà nó được lưu trữ có thể được sao lưu thay vì toàn bộ ổ đĩa vật lý.
   * Các phân vùng giúp cho việc khôi phục dữ liệu trở nên thuận tiện và hiệu quả.
      
 ## Phân quyền với lệnh fdisk
 fdisk được khởi động bằng cách gõ thiết bị fdisk (với tư cách gốc) tại dấu nhắc lệnh. thiết bị có thể giống như / dev / hda hoặc / dev / sda (xem Phần 2.1.1). Các lệnh fdisk cơ bản bạn cần là:

|COMMAND| ACTION |
| :---- | :---- |
p | in bảng phân vùng
n | tạo một phân vùng mới
d | xóa một phân vùng
q | thoát mà không lưu các thay đổi
w | viết bảng phân vùng mới và thoát
# RAID
* RAID là chữ viết tắt của Redundant Array of Independent Disks. Ban đầu, RAID được sử dụng như một giải pháp phòng hộ vì nó cho phép ghi dữ liệu lên nhiều đĩa cứng cùng lúc. Về sau, RAID đã có nhiều biến thể cho phép không chỉ đảm bảo an toàn dữ liệu mà còn giúp gia tăng đáng kể tốc độ truy xuất dữ liệu từ đĩa cứng. Dưới đây là năm loại RAID được dùng phổ biến:

* Có thể hiểu nhanh về RAID qua thông tin dưới đây:
   * RAID chỉ nên làm việc với các loại ổ cứng dung lượng bằng nhau.
   * Sử dụng RAID sẽ tốn số lượng ổ nhiều hơn bình thường, nhưng đổi lại là dữ liệu sẽ an toàn hơn.
   * RAID có thể dùng cho bất kỳ hệ điều hành nào, Window, MAC OS X, Linux…vv
   * RAID 0 bằng tổng dung lượng các ổ cộng lại.
   * RAID 1 chỉ duy trì dung lượng 1 ổ.
   * RAID 5 sẽ có dung lượng ít hơn 1 ổ (5 ổ dùng raid 5 sẽ có dung lượng 4 ổ).
   * RAID 10 sẽ chỉ tạo được khi số ổ là chẵn, phải có tối thiểu từ ô ổ trở lên. Dung lượng bằng tổng số ổ chia đôi (10 ổ thì dung lượng sử dụng là 5 ổ).
   ## RAID 0
 ![image](https://user-images.githubusercontent.com/91528234/199191680-8cc51e6b-bcf1-4a2a-889f-402543bbdd9a.png)
 * Đây là dạng RAID đang được người dùng ưa thích do khả năng nâng cao hiệu suất trao đổi dữ liệu của đĩa cứng. Đòi hỏi tối thiểu hai đĩa cứng, RAID 0 cho phép máy tính ghi dữ liệu lên chúng theo một phương thức đặc biệt được gọi là Striping. Ví dụ bạn có 8 đoạn dữ liệu được đánh số từ 1 đến 8, các đoạn đánh số lẻ (1,3,5,7) sẽ được ghi lên đĩa cứng đầu tiên và các đoạn đánh số chẵn (2,4,6,8) sẽ được ghi lên đĩa thứ hai. Để đơn giản hơn, bạn có thể hình dung mình có 100MB dữ liệu và thay vì dồn 100MB vào một đĩa cứng duy nhất, RAID 0 sẽ giúp dồn 50MB vào mỗi đĩa cứng riêng giúp giảm một nửa thời gian làm việc theo lý thuyết. Từ đó bạn có thể dễ dàng suy ra nếu có 4, 8 hay nhiều đĩa cứng hơn nữa thì tốc độ sẽ càng cao hơn. Tuy nghe có vẻ hấp dẫn nhưng trên thực tế, RAID 0 vẫn ẩn chứa nguy cơ mất dữ liệu. Nguyên nhân chính lại nằm ở cách ghi thông tin xé lẻ vì như vậy dữ liệu không nằm hoàn toàn ở một đĩa cứng nào và mỗi khi cần truy xuất thông tin (ví dụ một file nào đó), máy tính sẽ phải tổng hợp từ các đĩa cứng. Nếu một đĩa cứng gặp trục trặc thì thông tin (file) đó coi như không thể đọc được và mất luôn. Thật may mắn là với công nghệ hiện đại, sản phẩm phần cứng khá bền nên những trường hợp mất dữ liệu như vậy xảy ra không nhiều.

* Có thể thấy RAID 0 thực sự thích hợp cho những người dùng cần truy cập nhanh khối lượng dữ liệu lớn, ví dụ các game thủ hoặc những người chuyên làm đồ hoạ, video số.
## RAID 1
![image](https://user-images.githubusercontent.com/91528234/199192151-75d0847a-aea0-44fd-b86c-c7ffa2534265.png)
* Đây là dạng RAID cơ bản nhất có khả năng đảm bảo an toàn dữ liệu. Cũng giống như RAID 0, RAID 1 đòi hỏi ít nhất hai đĩa cứng để làm việc. Dữ liệu được ghi vào 2 ổ giống hệt nhau (Mirroring). Trong trường hợp một ổ bị trục trặc, ổ còn lại sẽ tiếp tục hoạt động bình thường. Bạn có thể thay thế ổ đĩa bị hỏng mà không phải lo lắng đến vấn đề thông tin thất lạc. Đối với RAID 1, hiệu năng không phải là yếu tố hàng đầu nên chẳng có gì ngạc nhiên nếu nó không phải là lựa chọn số một cho những người say mê tốc độ. Tuy nhiên đối với những nhà quản trị mạng hoặc những ai phải quản lý nhiều thông tin quan trọng thì hệ thống RAID 1 là thứ không thể thiếu. Dung lượng cuối cùng của hệ thống RAID 1 bằng dung lượng của ổ đơn (hai ổ 80GB chạy RAID 1 sẽ cho hệ thống nhìn thấy duy nhất một ổ RAID 80GB).
# RAID 5
![image](https://user-images.githubusercontent.com/91528234/199192289-bdf767fa-7695-4924-bd37-0e6873c99226.png)
* y có lẽ là dạng RAID mạnh mẽ nhất cho người dùng văn phòng và gia đình với 3 hoặc 5 đĩa cứng riêng biệt. Dữ liệu và bản sao lưu được chia lên tất cả các ổ cứng. Nguyên tắc này khá rối rắm. Chúng ta quay trở lại ví dụ về 8 đoạn dữ liệu (1-8) và giờ đây là 3 ổ đĩa cứng. Đoạn dữ liệu số 1 và số 2 sẽ được ghi vào ổ đĩa 1 và 2 riêng rẽ, đoạn sao lưu của chúng được ghi vào ổ cứng 3. Đoạn số 3 và 4 được ghi vào ổ 1 và 3 với đoạn sao lưu tương ứng ghi vào ổ đĩa 2. Đoạn số 5, 6 ghi vào ổ đĩa 2 và 3, còn đoạn sao lưu được ghi vào ổ đĩa 1 và sau đó trình tự này lặp lại, đoạn số 7,8 được ghi vào ổ 1, 2 và đoạn sao lưu ghi vào ổ 3 như ban đầu. Như vậy RAID 5 vừa đảm bảo tốc độ có cải thiện, vừa giữ được tính an toàn cao. Dung lượng đĩa cứng cuối cùng bằng tổng dung lượng đĩa sử dụng trừ đi một ổ. Tức là nếu bạn dùng 3 ổ 80GB thì dung lượng cuối cùng sẽ là 160GB.
## RAID 10
*  bao giờ bạn ao ước một hệ thống lưu trữ nhanh nhẹn như RAID 0, an toàn như RAID 1 hay chưa? Chắc chắn là có và hiển nhiên ước muốn đó không chỉ của riêng bạn. Chính vì thế mà hệ thống RAID kết hợp 0+1 đã ra đời, tổng hợp ưu điểm của cả hai “đàn anh”. Tuy nhiên chi phí cho một hệ thống kiểu này khá đắt, bạn sẽ cần tối thiểu 4 đĩa cứng để chạy RAID 0+1. Dữ liệu sẽ được ghi đồng thời lên 4 đĩa cứng với 2 ổ dạng Striping tăng tốc và 2 ổ dạng Mirroring sao lưu. 4 ổ đĩa này phải giống hệt nhau và khi đưa vào hệ thống RAID 0+1, dung lượng cuối cùng sẽ bằng ½ tổng dung lượng 4 ổ, ví dụ bạn chạy 4 ổ 80GB thì lượng dữ liệu “thấy được” là (4*80)/2 = 160GB

## Lựa chọn theo nhu cầu
![image](https://user-images.githubusercontent.com/91528234/199192971-06133a58-1a9e-4411-8fe3-81c98f7fab81.png)

## Lệnh mdadm



