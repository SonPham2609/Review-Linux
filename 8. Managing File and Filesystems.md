# Linux File System
* Hệ thống tệp (file) Linux là một tập hợp có cấu trúc các tệp trên ổ đĩa hoặc một phân vùng. Phân vùng là một phân đoạn bộ nhớ và chứa một số dữ liệu cụ thể. Trong máy của chúng ta, có thể có nhiều phân vùng bộ nhớ khác nhau. Nói chung, mọi phân vùng đều chứa một hệ thống tệp.
* Hệ thống máy tính đa năng cần lưu trữ dữ liệu một cách có hệ thống để chúng ta có thể dễ dàng truy cập các tệp trong thời gian ngắn hơn. Nó lưu trữ dữ liệu trên đĩa cứng (HDD) hoặc một số loại lưu trữ tương đương. Có thể có những lý do dưới đây để duy trì hệ thống tệp:

    * Chủ yếu máy tính lưu dữ liệu vào bộ nhớ RAM; nó có thể mất dữ liệu nếu nó bị tắt. Tuy nhiên, có sẵn RAM bất biến (RAM Flash và SSD) để duy trì dữ liệu sau khi ngắt nguồn.

    * Việc lưu trữ dữ liệu được ưu tiên trên ổ cứng so với RAM tiêu chuẩn vì RAM tốn nhiều dung lượng hơn dung lượng đĩa. Chi phí đĩa cứng đang giảm dần so với RAM.
* Hệ thống tệp Linux chứa các phần sau:

    * Thư mục gốc (/)

    * Định dạng lưu trữ dữ liệu cụ thể (EXT3, EXT4, BTRFS, XFS, v.v.)

    * Một phân vùng hoặc ổ đĩa hợp lý có một hệ thống tệp cụ thể.
## Cấu trúc hệ thống tệp Linux
* Hệ thống tệp Linux có cấu trúc tệp phân cấp vì nó chứa thư mục gốc và các thư mục con của nó.ất cả các thư mục khác có thể được truy cập từ thư mục gốc. Một phân vùng thường chỉ có một hệ thống tệp, nhưng nó có thể có nhiều hơn một hệ thống tệp.

*  Hệ thống tệp được thiết kế theo cách để nó có thể quản lý và cung cấp không gian cho dữ liệu lưu trữ không thay đổi. Tất cả các hệ thống tệp đều yêu cầu một không gian tên là phương pháp đặt tên và tổ chức. Không gian tên xác định quy trình đặt tên, độ dài của tên tệp hoặc một tập hợp con các ký tự có thể được sử dụng cho tên tệp. Nó cũng xác định cấu trúc logic của các tệp trên một phân đoạn bộ nhớ, chẳng hạn như việc sử dụng các thư mục để tổ chức các tệp cụ thể. Khi không gian tên được mô tả, mô tả Siêu dữ liệu phải được xác định cho tệp cụ thể đó.

* Cấu trúc dữ liệu cần hỗ trợ cấu trúc thư mục phân cấp; cấu trúc này được sử dụng để mô tả không gian đĩa có sẵn và được sử dụng cho một khối cụ thể. Nó cũng có các chi tiết khác về tệp như kích thước tệp, ngày và giờ tạo, cập nhật và sửa đổi lần cuối.
* Ngoài ra, nó lưu trữ thông tin nâng cao về phần của đĩa, chẳng hạn như phân vùng và ổ đĩa.

* Dữ liệu nâng cao và cấu trúc mà nó đại diện chứa thông tin về hệ thống tệp được lưu trữ trên ổ đĩa; nó khác biệt và độc lập với siêu dữ liệu hệ thống tệp.

* Hệ thống tệp Linux chứa kiến ​​trúc triển khai phần mềm hệ thống tệp gồm hai phần. Hãy xem xét hình ảnh dưới đây:

![image](https://user-images.githubusercontent.com/91528234/199150030-927ce7b2-c770-48e8-86f5-70b0e92f6eeb.png)

* Hệ thống tệp yêu cầu một API (Giao diện lập trình ứng dụng) để truy cập các lệnh gọi hàm để tương tác với các thành phần của hệ thống tệp như tệp và thư mục. API hỗ trợ các tác vụ như tạo, xóa và sao chép tệp. Nó tạo điều kiện cho một thuật toán xác định sự sắp xếp của các tệp trên một hệ thống tệp.

* Hai phần đầu tiên của hệ thống tệp nhất định được gọi là hệ thống tệp ảo Linux. Nó cung cấp một bộ lệnh duy nhất để hạt nhân và các nhà phát triển truy cập vào hệ thống tệp. Hệ thống tệp ảo này yêu cầu trình điều khiển hệ thống cụ thể cung cấp giao diện cho hệ thống tệp.
## Các tính năng của hệ thống tệp Linux
* Trong Linux, hệ thống tệp tạo ra một cấu trúc cây. Tất cả các tệp được sắp xếp như một cái cây và các nhánh của nó. Thư mục trên cùng được gọi là thư mục gốc (/). Tất cả các thư mục khác trong Linux có thể được truy cập từ thư mục gốc.

* Một số tính năng chính của hệ thống tệp Linux như sau:

    * **Chỉ định đường dẫn**: Sử dụng dấu gạch chéo (/) để chia các thành phần. Dữ liệu sẽ được lưu trữ trong /home/MyDocument/Work.

    * **Phân vùng, Thư mục và Ổ đĩa**: Linux không sử dụng ký tự ổ đĩa để tổ chức ổ đĩa như Windows. Trong Linux,  không thể biết liệu chúng đang định địa chỉ một phân vùng, một thiết bị mạng hay một thư mục "thông thường" và một Ổ đĩa.

    * **Phân biệt chữ hoa chữ thường**: Hệ thống tệp Linux phân biệt chữ hoa chữ thường. Nó phân biệt giữa tên tệp viết thường và viết hoa. Chẳng hạn, có sự khác biệt giữa test.txt và Test.txt trong Linux. Quy tắc này cũng được áp dụng cho các thư mục và lệnh Linux.

    * **Phần mở rộng tệp**: Trong Linux, tệp có thể có phần mở rộng là '.txt', nhưng không nhất thiết tệp phải có phần mở rộng tệp. Trong khi làm việc với Shell, nó tạo ra một số vấn đề cho người mới bắt đầu để phân biệt giữa các tệp và thư mục. Nếu chúng ta sử dụng trình quản lý tệp đồ họa, nó tượng trưng cho các tệp và thư mục.

    * **Tệp ẩn**: Linux phân biệt giữa tệp tiêu chuẩn và tệp ẩn, hầu hết các tệp cấu hình được ẩn trong Hệ điều hành Linux. Thông thường, chúng ta không cần truy cập hoặc đọc các tệp ẩn. Các tệp ẩn trong Linux được biểu thị bằng dấu chấm (.) Trước tên tệp (ví dụ: .ignore). Để truy cập các tệp, chúng ta cần thay đổi chế độ xem trong trình quản lý tệp hoặc cần sử dụng một lệnh cụ thể trong trình bao.
 ## Các loại hệ thống tệp Linux
 * Khi chúng ta cài đặt hệ điều hành Linux, Linux cung cấp nhiều hệ thống tệp như Ext, Ext2, Ext3, Ext4, JFS, ReiserFS, XFS, btrfs và swap.
 ![image](https://user-images.githubusercontent.com/91528234/199150947-0ed029a9-49bb-4fbd-b38b-541b2e71dd5f.png)
 ### Ext, Ext2, Ext3 and Ext4 file system
 * Hệ thống tập tin Ext là viết tắt của **Extended File System**. Nó chủ yếu được phát triển cho **MINIX OS**. Hệ thống tệp Ext là phiên bản cũ hơn và không còn được sử dụng do một số hạn chế.

* **Ext2** là hệ thống tệp Linux đầu tiên cho phép quản lý hai terabyte dữ liệu. Ext3 được phát triển thông qua Ext2; nó là phiên bản nâng cấp của Ext2 và có khả năng tương thích ngược. Hạn chế lớn của Ext3 là không hỗ trợ máy chủ vì hệ thống tệp này không hỗ trợ khôi phục tệp và ảnh chụp nhanh đĩa.

* Hệ thống tệp **Ext4** là hệ thống tệp nhanh hơn trong số tất cả các hệ thống tệp Ext. Đây là một tùy chọn rất tương thích cho các đĩa SSD (ổ thể rắn) và nó là hệ thống tệp mặc định trong bản phân phối Linux.
### JFS File System
* **JFS** là viết tắt của **Journaled File System**, và nó được **IBM phát triển cho AIX Unix**. Nó là một thay thế cho hệ thống tệp Ext. Nó cũng có thể được sử dụng thay cho Ext4, nơi cần sự ổn định với ít tài nguyên. Nó là một hệ thống tệp tiện dụng khi sức mạnh của CPU bị hạn chế.

### Hệ thống tệp ReiserFS

**ReiserFS** là một giải pháp thay thế cho hệ thống tệp Ext3. Nó đã được cải thiện hiệu suất và các tính năng nâng cao. Trong thời gian trước đó, ReiserFS được sử dụng làm hệ thống tệp mặc định trong SUSE Linux, nhưng sau đó nó đã thay đổi một số chính sách nên SUSE quay trở lại Ext3. Hệ thống tệp này hỗ trợ động phần mở rộng tệp, nhưng nó có một số hạn chế về hiệu suất.


### Hệ thống tệp XFS

* Hệ thống tệp **XFS** được coi là JFS tốc độ cao, được phát triển để xử lý I/O song song. NASA vẫn đang sử dụng hệ thống tệp này với máy chủ lưu trữ cao (máy chủ 300+ Terabyte).

### Hệ thống tệp Btrfs

* **Btrfs** là viết tắt của hệ thống tệp B cây. Nó được sử dụng để chịu lỗi, sửa chữa hệ thống, quản trị vui vẻ, cấu hình lưu trữ mở rộng và hơn thế nữa. Nó không phải là một phù hợp tốt cho hệ thống sản xuất.

### Hoán đổi hệ thống tệp

Hệ thống tệp hoán đổi được sử dụng để phân trang bộ nhớ trong hệ điều hành Linux trong chế độ ngủ đông của hệ thống. Một hệ thống không bao giờ ở trạng thái ngủ đông bắt buộc phải có không gian hoán đổi bằng với kích thước RAM của nó.

# Lệnh Fsck trong linux (sửa chữa hệ thống tập tin)
* fsck (kiểm tra hệ thống tệp) là một tiện ích dòng lệnh cho phép bạn thực hiện kiểm tra tính nhất quán và sửa chữa tương tác trên một hoặc nhiều hệ thống tệp Linux. Nó sử dụng các chương trình dành riêng cho loại hệ thống tập tin mà nó kiểm tra.
## Cách sử dụng fsck
Lệnh fsck có dạng chung sau:
```
fsck
```
* Chỉ người dùng root hoặc người dùng có quyền sudo có thể xóa bộ đệm.

* Khi không có `FILESYSTEM` nào được cung cấp làm đối số, fsck kiểm tra các thiết bị được liệt kê trong tệp fstab .

* Không bao giờ chạy fsck trên các phân vùng được gắn vì nó có thể làm hỏng hệ thống tệp. Trước khi thử kiểm tra hoặc sửa chữa các hệ thống tập tin luôn `unmount` nó trước.

* Lệnh fsck là một trình bao bọc cho các trình kiểm tra hệ thống tệp Linux khác nhau ( fsck.* ) Và chấp nhận các tùy chọn khác nhau tùy thuộc vào loại hệ thống tệp.

Kiểm tra các trang hướng dẫn để biết thêm thông tin về một trình kiểm tra cụ thể. Ví dụ: để xem các tùy chọn khả dụng cho fsck.ext4 , hãy nhập:
```
man fsck.ext4
```
## Khi nào thì dùng fsck trong Linux
* Có nhiều tình huống khác nhau khi bạn muốn chạy fsck. Dưới đây là một số ví dụ:

* Hệ thống không khởi động được.

* Các tệp trên hệ thống bị hỏng (thường thì bạn có thể thấy lỗi đầu vào/đầu ra).

* Ổ đĩa đính kèm (bao gồm ổ đĩa flash/thẻ SD) không hoạt động như mong đợi.
## Các tùy chọn có sẵn của fsck
* Lệnh Fsck cần được chạy với các đặc quyền của superuser hoặc **root**. Bạn có thể sử dụng nó với các đối số khác nhau. Việc sử dụng chúng tùy thuộc vào trường hợp cụ thể của bạn. Dưới đây, bạn sẽ thấy một số tùy chọn quan trọng hơn:

|OPTION| ACTION |
| :---- | :---- |
-A | - Được sử dụng để kiểm tra tất cả các hệ thống tập tin. Danh sách được lấy từ / etc / fstab.
-C | - Hiển thị thanh tiến trình.
-l | - Khóa thiết bị để đảm bảo không có chương trình nào khác cố gắng sử dụng phân vùng trong quá trình kiểm tra.
-M | - Không kiểm tra hệ thống tập tin được gắn kết.
-N | - Chỉ hiển thị những gì sẽ được thực hiện - không có thay đổi thực tế nào được thực hiện.
-P | - Nếu bạn muốn kiểm tra song song các hệ thống tập tin, bao gồm cả root.
-R | - Không kiểm tra hệ thống tập tin gốc. Điều này chỉ hữu ích với ‘-A‘.
-r | - Cung cấp số liệu thống kê cho từng thiết bị đang được kiểm tra.
-T | - Không hiển thị tiêu đề.
-t | - Chỉ định riêng các loại hệ thống tệp được kiểm tra. Các loại có thể là danh sách được phân tách bằng dấu phẩy.
-V | - Cung cấp mô tả những gì đang được thực hiện.
## Cách chạy fsck để sửa lỗi hệ thống tệp Linux
* Trường hợp sử dụng đơn giản nhất của lệnh fsck là sửa chữa một hệ thống tệp ext3 hoặc ext4 không root bị hỏng.

* Ngắt kết nối thiết bị:
```
sudo umount /dev/sda1
```
Chạy fsck để sửa chữa hệ thống tập tin:
```
sudo fsck -p /dev/sda1
```
Tùy chọn `-p` yêu cầu fsck tự động sửa chữa mọi sự cố có thể được khắc phục một cách an toàn mà không cần sự can thiệp của người dùng.

Khi hệ thống tập tin được sửa chữa, gắn kết phân vùng:
```
sudo mount /dev/sda1
```
# Monitoring Disk
## Lệnh df
* Lệnh “df” viết tắt của “disk filesystem“, nó được dùng để lấy toàn bộ thông tin về lượng ổ cứng khả dụng và lượng ổ cứng đã dùng của các file hệ thống trên linux. Cách đơn giản nhất để kiểm tra dung lượng đĩa là ta sử dụng lệnh `df`:

![image](https://user-images.githubusercontent.com/91528234/199157000-dbc89421-d653-4972-9431-1500436c6898.png)

* Trong đó:

   * filesystem: tên filesystem có thể trùng với phân vùng đĩa.
   * 1K-blocks: Số lượng khối (block) có trong filesystem có kích thước 1Kb.
   * Used: Số lượng 1K-block được sử dụng trong filesystem.
   * Available: Số lượng 1K-block đang có sẵn.
   * Use%: Phần trăm đĩa đã sử dụng trong filesystem.
   * Mounted on: Nơi mount.
* Lệnh `df` được đi kèm với một số tùy chọn để hiển thị nội dung rõ ràng và thân thiện với người dùng hơn.
Tùy chọn `-h` cho ta một cái nhìn trực quan hơn khi đọc các thông số ở chế độ chi tiết : bytes, megabytes và gigabytes.

![image](https://user-images.githubusercontent.com/91528234/199157332-6daa82b5-b3ef-4f01-8993-e8cba2c45b42.png)
## Kiểm tra dung lượng đĩa với các trường hợp cụ thể
* Để kiểm tra space của một đĩa/phân vùng cụ thể, bạn sử dụng lệnh df với cú pháp:
```
df <option> path
```
* Một số ví dụ:
     * Kiểm tra dung lượng ổ đĩa phân vùng
     ![image](https://user-images.githubusercontent.com/91528234/199157667-92a505ad-f319-445a-abce-472026e42db6.png)
* Bạn có thể cờ `output` đi kèm lệnh df:
```
df -h --output='field1', 'field2' /
```
      Kiểm tra kích thước và phần trăm đĩa đã sử dụng, ta gõ lệnh:
      ![image](https://user-images.githubusercontent.com/91528234/199157947-dd02236c-d3c5-4e2f-919f-cf5f735ac495.png)
## Lệnh du
* du là một công cụ dòng lệnh được cung cấp bởi Linux, nhằm báo cáo dung lượng ổ đĩa được sử dụng bởi các thư mục và **file.du** là viết tắt của từ “disk usage”. Đây là công cụ chính để phân tích không gian ổ đĩa trong dòng lệnh.
```
du <option> <path|file>
du <option> <path1> <path2> <path3>  
```
* Kiểm tra dung lượng của một file cụ thể
Ví dụ để kiểm tra kích thước của một file .bashrc, bạn có thể chạy lệnh:
![image](https://user-images.githubusercontent.com/91528234/199158729-4e8d56f6-ada1-49a2-8fef-75e0cef44589.png)
## Kiểm tra dung lượng đĩa đã sử dụng cho các thư mục
* Bạn có thể kiểm tra dung lượng đĩa được sử dụng cho thư mục bằng lệnh du với tên đường dẫn cụ thể. Tuy nhiên trong một vài trường hợp bạn không muốn nhìn thấy output của tất cả file hoặc thư mục riêng lẻ, bạn có thể sử dụng tùy chọn `-shc`. Ví dụ dưới đây, tôi muốn kiểm tra dung lượng đĩa đã sử dụng cho thư mục /home hoặc /var/log.
![image](https://user-images.githubusercontent.com/91528234/199159211-4b39670c-9169-463c-8549-bbd019cc67c7.png)
* Ý nghĩa của các tùy chọn:

   * `-s`: dùng để tóm tắt, nó sẽ hiển thị tổng số đường dẫn được cung cấp thay vì hiển thị danh sách tất cả các tệp và thư mục.
   * `-h`: để con người có thể đọc được, nó sẽ hiển thị kết quả với các đơn vị.
   * `-c`: đối với tổng số lớn, nếu bạn chỉ định nhiều đường dẫn, nó sẽ tổng hợp chúng để tạo ra tổng số lớn cho chúng.
   # Tạo file Systems
   
* Lệnh mkfs xây dựng hệ thống tệp trên thiết bị khối:
```
# mkfs [option] device
```
* mkfs là giao diện người dùng cho các tiện ích trình tạo trong /sbin chẳng hạn như **mkfs.ext4**. Bạn có thể sử dụng lệnh mkfs với tùy chọn `-t` fstype hoặc tiện ích trình tạo để chỉ định loại hệ thống tệp cần xây dựng. Ví dụ: các lệnh sau là các cách tương đương để tạo hệ thống tệp ext4 với nhãn Dự án trên thiết bị /dev/sdb1:
```
# mkfs -t ext4 -L Projects /dev/sdb1
# mkfs.ext4 -L Projects /dev/sdb1
```
* và xem file đã được khởi tạo chưa với lệnh
```
lsblk
```
# Mounting and Unmounting Filesystems
* Để truy cập nội dung của hệ thống tệp, bạn phải gắn thiết bị khối của nó vào một điểm gắn kết trong hệ thống phân cấp thư mục. Bạn có thể sử dụng lệnh mkdir để tạo một thư mục để sử dụng làm điểm gắn kết, ví dụ:
```
# mkdir /var/project
```

* Bạn có thể sử dụng một thư mục hiện có làm điểm gắn kết, nhưng nội dung của nó sẽ bị ẩn cho đến khi bạn ngắt kết nối hệ thống tệp cơ bản.

* Lệnh mount sẽ gắn thiết bị chứa hệ thống tệp vào điểm mount:
```
# mount [options] device mount_point 
```

* Bạn có thể chỉ định thiết bị theo tên, UUID hoặc nhãn của nó. Ví dụ: các lệnh sau là các cách tương đương để gắn hệ thống tệp trên thiết bị khối /dev/sdb1:
```
# mount /dev/sdb1/var/project
# mount LABEL = "projects" /var/project
```

* Nếu bạn không chỉ định bất kỳ đối số nào, mount sẽ hiển thị tất cả các hệ thống tệp mà hệ thống hiện đã gắn kết, ví dụ:
```
# mout
/dev/mapper/vg_host01-lv_root on / type ext4 (rw)
...
```
* Trong ví dụ này, LVM logic volume/dev/mapper/ vg_host01-lv_root được gắn trên /. Loại hệ thống tệp là ext4 và được gắn cho cả việc đọc và ghi. (Bạn cũng có thể sử dụng lệnh cat /proc/mounts để hiển thị thông tin về hệ thống tệp được gắn kết.)

Lệnh df hiển thị thông tin về không gian còn lại trong nhà trên các hệ thống tệp được gắn kết, ví dụ:
```
# df -h
Filesystem                     Size  Used Avail Use% Mounted on
/dev/mapper/vg_host01-lv_root  36G   12G   22G  36% /
...
```

* Bạn có thể sử dụng tùy chọn -B (bind) cho lệnh mount để gắn thiết bị khối tại nhiều điểm mount. Bạn cũng có thể đếm lại một phần của hệ thống phân cấp thư mục, không cần phải là một hệ thống tệp hoàn chỉnh, ở một nơi khác. Ví dụ, lệnh sau mounts /var/project/project1 on/mnt:
```
# mount -B /var/projects/project1 /mnt
```
* Mỗi hệ thống phân cấp thư mục hoạt động như một bản sao của hệ thống phân cấp khác. Các tệp giống nhau đều có thể truy cập được ở cả hai vị trí, mặc dù bất kỳ số lượng con nào không được sao chép. Những gương này không cung cấp dự phòng dữ liệu.

* Bạn cũng có thể gắn kết một tệp trên một tệp khác, ví dụ:
```
# touch /mnt/foo

# mount -B /etc/hosts/mnt/foo
```
* Trong ví dụ này, /etc/hosts và /mnt/foo đại diện cho cùng một tệp. Không thể truy cập tệp hiện có hoạt động như một điểm gắn kết cho đến khi bạn ngắt kết nối tệp bên trên.

Tùy chọn `-B` không đính kèm đệ quy bất kỳ tài khoản con nào bên dưới hệ thống phân cấp thư mục. Để bao gồm các số lượng con trong nhân bản, hãy sử dụng tùy chọn `-R` (liên kết đệ quy) để thay thế.

Khi bạn sử dụng `-B` hoặc `-R`, các tùy chọn gắn kết hệ thống tệp vẫn giống như các tùy chọn cho điểm gắn kết ban đầu. Để sửa đổi các tùy chọn gắn kết, hãy sử dụng một lệnh remount riêng, ví dụ:
```
# mount -o remount,ro /mnt/foo
```
* Để ngắt kết nối hệ thống tệp, hãy sử dụng lệnh umount, ví dụ:
```
# umount /var/project
```
# Partitioning Disks( Phân vùn ổ đĩa)
* Phân vùng đĩa là quá trình chia đĩa thành một hoặc nhiều vùng được gọi là phân vùng. Bảng phân vùng nằm trong khu vực đầu tiên của đĩa và lưu trữ thông tin về kích thước và vị trí của các phân vùng đã tạo. Nói cách khác, phân vùng đĩa cho phép chia một ổ đĩa vật lý thành các ổ đĩa logic nhỏ hơn được gọi là ổ đĩa. Đối với một hệ điều hành, các ổ đĩa này hoàn toàn riêng biệt, vì vậy bạn có thể thực hiện các thao tác trên một ổ đĩa mà không ảnh hưởng đến các ổ đĩa khác.

* Hầu hết người dùng sẽ không bao giờ gặp phải nhu cầu phân vùng đĩa, nhưng phân vùng đĩa có thể hữu ích trong một số trường hợp.

   * Một ổ cứng mới thực tế không thể sử dụng được trừ khi nó được phân vùng để lưu dữ liệu.

   * Các phân vùng có thể được sử dụng để tổ chức dữ liệu theo kiểu của chúng. Ví dụ: bạn có thể có một phân vùng lưu trữ tất cả các tài liệu của bạn và một phân vùng khác lưu trữ tất cả các tệp nhạc của bạn.

   * Windows có thể dễ dàng được cài đặt lại mà không ảnh hưởng đến các chương trình đã cài đặt vì các tệp khởi động được lưu trữ an toàn trong phân vùng hệ thống. Phân vùng hệ thống được giữ riêng biệt với phần còn lại của các phân vùng lưu trữ các ứng dụng đã cài đặt.
   * Nếu bạn muốn sao lưu một tập hợp con dữ liệu nhất định, phân vùng mà nó được lưu trữ có thể được sao lưu thay vì toàn bộ ổ đĩa vật lý.
   * Các phân vùng giúp cho việc khôi phục dữ liệu trở nên thuận tiện và hiệu quả.
      
 ## Phân quyền với lệnh fdisk
 fdisk được khởi động bằng cách gõ thiết bị fdisk (với tư cách gốc) tại dấu nhắc lệnh. thiết bị có thể giống như / dev / hda hoặc / dev / sda (xem Phần 2.1.1). Các lệnh fdisk cơ bản bạn cần là:

|OPTION| ACTION |
| :---- | :---- |
p | in bảng phân vùng
n | tạo một phân vùng mới
d | xóa một phân vùng
q | thoát mà không lưu các thay đổi
w | viết bảng phân vùng mới và thoát
# RAID
* RAID là chữ viết tắt của Redundant Array of Independent Disks. Ban đầu, RAID được sử dụng như một giải pháp phòng hộ vì nó cho phép ghi dữ liệu lên nhiều đĩa cứng cùng lúc. Về sau, RAID đã có nhiều biến thể cho phép không chỉ đảm bảo an toàn dữ liệu mà còn giúp gia tăng đáng kể tốc độ truy xuất dữ liệu từ đĩa cứng. Dưới đây là năm loại RAID được dùng phổ biến:

* Có thể hiểu nhanh về RAID qua thông tin dưới đây:
   * RAID chỉ nên làm việc với các loại ổ cứng dung lượng bằng nhau.
   * Sử dụng RAID sẽ tốn số lượng ổ nhiều hơn bình thường, nhưng đổi lại là dữ liệu sẽ an toàn hơn.
   * RAID có thể dùng cho bất kỳ hệ điều hành nào, Window, MAC OS X, Linux…vv
   * RAID 0 bằng tổng dung lượng các ổ cộng lại.
   * RAID 1 chỉ duy trì dung lượng 1 ổ.
   * RAID 5 sẽ có dung lượng ít hơn 1 ổ (5 ổ dùng raid 5 sẽ có dung lượng 4 ổ).
   * RAID 10 sẽ chỉ tạo được khi số ổ là chẵn, phải có tối thiểu từ ô ổ trở lên. Dung lượng bằng tổng số ổ chia đôi (10 ổ thì dung lượng sử dụng là 5 ổ).
   ## RAID 0
 ![image](https://user-images.githubusercontent.com/91528234/199191680-8cc51e6b-bcf1-4a2a-889f-402543bbdd9a.png)
 * Đây là dạng RAID đang được người dùng ưa thích do khả năng nâng cao hiệu suất trao đổi dữ liệu của đĩa cứng. Đòi hỏi tối thiểu hai đĩa cứng, RAID 0 cho phép máy tính ghi dữ liệu lên chúng theo một phương thức đặc biệt được gọi là Striping. Ví dụ bạn có 8 đoạn dữ liệu được đánh số từ 1 đến 8, các đoạn đánh số lẻ (1,3,5,7) sẽ được ghi lên đĩa cứng đầu tiên và các đoạn đánh số chẵn (2,4,6,8) sẽ được ghi lên đĩa thứ hai. Để đơn giản hơn, bạn có thể hình dung mình có 100MB dữ liệu và thay vì dồn 100MB vào một đĩa cứng duy nhất, RAID 0 sẽ giúp dồn 50MB vào mỗi đĩa cứng riêng giúp giảm một nửa thời gian làm việc theo lý thuyết. Từ đó bạn có thể dễ dàng suy ra nếu có 4, 8 hay nhiều đĩa cứng hơn nữa thì tốc độ sẽ càng cao hơn. Tuy nghe có vẻ hấp dẫn nhưng trên thực tế, RAID 0 vẫn ẩn chứa nguy cơ mất dữ liệu. Nguyên nhân chính lại nằm ở cách ghi thông tin xé lẻ vì như vậy dữ liệu không nằm hoàn toàn ở một đĩa cứng nào và mỗi khi cần truy xuất thông tin (ví dụ một file nào đó), máy tính sẽ phải tổng hợp từ các đĩa cứng. Nếu một đĩa cứng gặp trục trặc thì thông tin (file) đó coi như không thể đọc được và mất luôn. Thật may mắn là với công nghệ hiện đại, sản phẩm phần cứng khá bền nên những trường hợp mất dữ liệu như vậy xảy ra không nhiều.

* Có thể thấy RAID 0 thực sự thích hợp cho những người dùng cần truy cập nhanh khối lượng dữ liệu lớn, ví dụ các game thủ hoặc những người chuyên làm đồ hoạ, video số.
## RAID 1
![image](https://user-images.githubusercontent.com/91528234/199192151-75d0847a-aea0-44fd-b86c-c7ffa2534265.png)
* Đây là dạng RAID cơ bản nhất có khả năng đảm bảo an toàn dữ liệu. Cũng giống như RAID 0, RAID 1 đòi hỏi ít nhất hai đĩa cứng để làm việc. Dữ liệu được ghi vào 2 ổ giống hệt nhau (Mirroring). Trong trường hợp một ổ bị trục trặc, ổ còn lại sẽ tiếp tục hoạt động bình thường. Bạn có thể thay thế ổ đĩa bị hỏng mà không phải lo lắng đến vấn đề thông tin thất lạc. Đối với RAID 1, hiệu năng không phải là yếu tố hàng đầu nên chẳng có gì ngạc nhiên nếu nó không phải là lựa chọn số một cho những người say mê tốc độ. Tuy nhiên đối với những nhà quản trị mạng hoặc những ai phải quản lý nhiều thông tin quan trọng thì hệ thống RAID 1 là thứ không thể thiếu. Dung lượng cuối cùng của hệ thống RAID 1 bằng dung lượng của ổ đơn (hai ổ 80GB chạy RAID 1 sẽ cho hệ thống nhìn thấy duy nhất một ổ RAID 80GB).
## RAID 5
![image](https://user-images.githubusercontent.com/91528234/199192289-bdf767fa-7695-4924-bd37-0e6873c99226.png)
* y có lẽ là dạng RAID mạnh mẽ nhất cho người dùng văn phòng và gia đình với 3 hoặc 5 đĩa cứng riêng biệt. Dữ liệu và bản sao lưu được chia lên tất cả các ổ cứng. Nguyên tắc này khá rối rắm. Chúng ta quay trở lại ví dụ về 8 đoạn dữ liệu (1-8) và giờ đây là 3 ổ đĩa cứng. Đoạn dữ liệu số 1 và số 2 sẽ được ghi vào ổ đĩa 1 và 2 riêng rẽ, đoạn sao lưu của chúng được ghi vào ổ cứng 3. Đoạn số 3 và 4 được ghi vào ổ 1 và 3 với đoạn sao lưu tương ứng ghi vào ổ đĩa 2. Đoạn số 5, 6 ghi vào ổ đĩa 2 và 3, còn đoạn sao lưu được ghi vào ổ đĩa 1 và sau đó trình tự này lặp lại, đoạn số 7,8 được ghi vào ổ 1, 2 và đoạn sao lưu ghi vào ổ 3 như ban đầu. Như vậy RAID 5 vừa đảm bảo tốc độ có cải thiện, vừa giữ được tính an toàn cao. Dung lượng đĩa cứng cuối cùng bằng tổng dung lượng đĩa sử dụng trừ đi một ổ. Tức là nếu bạn dùng 3 ổ 80GB thì dung lượng cuối cùng sẽ là 160GB.
## RAID 10
*  bao giờ bạn ao ước một hệ thống lưu trữ nhanh nhẹn như RAID 0, an toàn như RAID 1 hay chưa? Chắc chắn là có và hiển nhiên ước muốn đó không chỉ của riêng bạn. Chính vì thế mà hệ thống RAID kết hợp 0+1 đã ra đời, tổng hợp ưu điểm của cả hai “đàn anh”. Tuy nhiên chi phí cho một hệ thống kiểu này khá đắt, bạn sẽ cần tối thiểu 4 đĩa cứng để chạy RAID 0+1. Dữ liệu sẽ được ghi đồng thời lên 4 đĩa cứng với 2 ổ dạng Striping tăng tốc và 2 ổ dạng Mirroring sao lưu. 4 ổ đĩa này phải giống hệt nhau và khi đưa vào hệ thống RAID 0+1, dung lượng cuối cùng sẽ bằng ½ tổng dung lượng 4 ổ, ví dụ bạn chạy 4 ổ 80GB thì lượng dữ liệu “thấy được” là (4*80)/2 = 160GB

## Lựa chọn theo nhu cầu
![image](https://user-images.githubusercontent.com/91528234/199192971-06133a58-1a9e-4411-8fe3-81c98f7fab81.png)

## Lệnh mdadm
* Tiện ích mdadm có thể được sử dụng để tạo và quản lý các mảng lưu trữ bằng khả năng RAID phần mềm của Linux. Quản trị viên có khả năng linh hoạt cao trong việc phối hợp các thiết bị lưu trữ riêng lẻ của họ và tạo ra các thiết bị lưu trữ hợp lý có hiệu suất cao hơn hoặc các đặc điểm dự phòng.
### VD về tạo RAID0 trên CentOS 7
#### Bước 1: Cập nhật hệ thống và cài đặt mdadm để quản lý RAID

Để thiết lập RAID0 trên hệ điều hành Linux chúng ta cần thực hiện cập nhật (update) hệ thống và cài đặt gói `mdadm`.

#### Bước 2: Kiểm tra thông tin ổ đĩa trên máy:

* Trước khi tạo RAID0, cần đảm bảo có ít nhất hai ổ đĩa cứng chạy lệnh sau để kiểm tra:
```
[root@localhost ~]# fdisk -l |grep sd
Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200    41943039    19921920   8e  Linux LVM
Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors
Disk /dev/sdc: 10.7 GB, 10737418240 bytes, 20971520 sectors
```
* Qua lệnh kiểm tra trên chúng ta thấy có 2 đĩa cứng mới được phát hiện, bây giờ chúng ta thực hiện kiểm tra xem các ổ cứng có sử dụng RAID nào chưa bằng lệnh mdadm cùng với tùy chọn --examine như bên dưới.
```
[root@localhost ~]# mdadm --examine /dev/sd[b-c]
mdadm: No md superblock detected on /dev/sdb.
mdadm: No md superblock detected on /dev/sdc.
```

* Kết trên trả về cho chúng ta biết rằng không có RAID nào được áp dụng cho hai ổ sdb và sdc.

#### Bước 3: Tạo phân vùng đĩa cứng

* Thực hiện tạo phân vùng trên đĩa có tên là sdb và sdc cho RAID bằng lệnh fdisk.

 **Tạo phân vùng trên ổ đĩa sdb**.

* Chạy lệnh fdisk /dev/sdb để tạo phân vùng cho sdb và thực hiện các thao tác sau:

   * Nhấn n để tạo phân vùng mới.
   * Sau đó chọn p cho phân vùng chính.
   * Tiếp theo chọn số phân vùng là 1 .
   * Nhập giá trị ban đầu, giá trị kết thúc và nhấn phím Enter.
   * Tiếp theo nhấn p để in phân vùng đã được tạo.
* Thực hiện các bước sau đây để tạo Linux RAID tự động trên các phân vùng:
   * Nhấn L để liệt kê tất cả các loại có sẵn.
   * Nhập t để chọn phân vùng.
   * Nhập fd để chọn Linux RAID tự động và nhấn Enter để áp dụng.
   * Sử dụng phím p để in những thay đổi.
   * Cuối cùng chúng ta nhấn phím w lưu các thay đổi.
* Các thao tác trên được thực hiện như sau:
```
[root@localhost ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xd1c9ae6a.

Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-20971519, default 2048): 2048
Last sector, +sectors or +size{K,M,G} (2048-20971519, default 20971519): 20971519
Partition 1 of type Linux and of size 10 GiB is set

Command (m for help): p

Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xd1c9ae6a

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    20971519    10484736   83  Linux

Command (m for help): L

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris
 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 <32M      40  Venix 80286     85  Linux extended  c7  Syrinx
 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data
 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility
 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt
 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access
 a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O
 b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor
 c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs
 e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT
 f  W95 Ext'd (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor
12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor
14  Hidden FAT16 <3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary
16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS
17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE
18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep
1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT
1e  Hidden W95 FAT1 80  Old Minix

Command (m for help): t
Selected partition 1
Hex code (type L to list all codes): fd
Changed type of partition 'Linux' to 'Linux raid autodetect'

Command (m for help): p

Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xd1c9ae6a

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    20971519    10484736   fd  Linux raid autodetect

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
```

* Tương tự như vậy chúng ta tạo phân vùng cho `sdc`.

* Sau khi tạo xong chúng ta chạy lệnh bên dưới kiểm tra xem phân vùng được tạo hay chưa.
```
[root@localhost ~]# fdisk -l | grep sd
Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200    41943039    19921920   8e  Linux LVM
Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors
/dev/sdb1            2048    20971519    10484736   fd  Linux raid autodetect
Disk /dev/sdc: 10.7 GB, 10737418240 bytes, 20971520 sectors
/dev/sdc1            2048    20971519    10484736   fd  Linux raid autodetect
```

* Tiếp theo chúng ta chạy lệnh bên dưới để kiểm tra xem các đĩa hiện có tham gia RAID nào không:
* 
```
[root@localhost ~]#  mdadm --examine /dev/sd[b-c]
/dev/sdb:
   MBR Magic : aa55
Partition[0] :     20969472 sectors at         2048 (type fd)
/dev/sdc:
   MBR Magic : aa55
Partition[0] :     20969472 sectors at         2048 (type fd)
[root@localhost ~]#  mdadm --examine /dev/sd[b-c]1
mdadm: No md superblock detected on /dev/sdb1.
mdadm: No md superblock detected on /dev/sdc1.
```
#### Bước 4: Tạo RAID0

* Chúng ta chạy lệnh sau để tạo RAID0:

```
[root@localhost ~]# mdadm -C /dev/md0 -l raid0 -n 2 /dev/sd[b-c]1
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.
```
* Trong đó:

   * C: Tạo RAID mới.
   * l: Level của RAID.
   * n: Không có thiết bị RAID.
* Ngoài ra lệnh tạo RAID0 sau đây cũng có ý nghĩa như lệnh chúng ta vừa chạy:
```
mdadm --create /dev/md0 --level=stripe --raid-devices=2 /dev/sd[b-c]1
```

* Kiểm tra lại RAID vừa tạo bằng các cách sau:

```
[root@localhost ~]# cat /proc/mdstat
Personalities : [raid0]
md0 : active raid0 sdc1[1] sdb1[0]
      20951040 blocks super 1.2 512k chunks

unused devices: <none>
```

* Qua kết quả trên cho chúng ta thấy RAID0 đã được tạo với hai phân vùng `sdb1` và `sdc1`. Chúng ta cũng có thể kiểm tra bằng lệnh bên dưới:

```
[root@localhost ~]# mdadm -E /dev/sd[b-c]1
/dev/sdb1:
          Magic : a92b4efc
        Version : 1.2
    Feature Map : 0x0
     Array UUID : 98cffedb:dd23fd6d:07b60209:b92643bd
           Name : localhost.localdomain:0  (local to host localhost.localdomain)
  Creation Time : Sun May 19 11:40:09 2019
     Raid Level : raid0
   Raid Devices : 2

 Avail Dev Size : 20951040 (9.99 GiB 10.73 GB)
    Data Offset : 18432 sectors
   Super Offset : 8 sectors
   Unused Space : before=18352 sectors, after=0 sectors
          State : clean
    Device UUID : fedf81e4:0cea1e46:3f96f2c1:9c4fa897

    Update Time : Sun May 19 11:40:09 2019
  Bad Block Log : 512 entries available at offset 8 sectors
       Checksum : af1ccef - correct
         Events : 0

     Chunk Size : 512K

   Device Role : Active device 0
   Array State : AA ('A' == active, '.' == missing, 'R' == replacing)
/dev/sdc1:
          Magic : a92b4efc
        Version : 1.2
    Feature Map : 0x0
     Array UUID : 98cffedb:dd23fd6d:07b60209:b92643bd
           Name : localhost.localdomain:0  (local to host localhost.localdomain)
  Creation Time : Sun May 19 11:40:09 2019
     Raid Level : raid0
   Raid Devices : 2

 Avail Dev Size : 20951040 (9.99 GiB 10.73 GB)
    Data Offset : 18432 sectors
   Super Offset : 8 sectors
   Unused Space : before=18352 sectors, after=0 sectors
          State : clean
    Device UUID : 7abd085c:5144fc8f:5a200101:4a70369c

    Update Time : Sun May 19 11:40:09 2019
  Bad Block Log : 512 entries available at offset 8 sectors
       Checksum : ff2af79 - correct
         Events : 0

     Chunk Size : 512K

   Device Role : Active device 1
   Array State : AA ('A' == active, '.' == missing, 'R' == replacing)
   ```
   
* Hoặc có thể chạy lệnh sau để kiểm tra:

```
[root@localhost ~]# mdadm --detail /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Sun May 19 11:40:09 2019
        Raid Level : raid0
        Array Size : 20951040 (19.98 GiB 21.45 GB)
      Raid Devices : 2
     Total Devices : 2
       Persistence : Superblock is persistent

       Update Time : Sun May 19 11:40:09 2019
             State : clean
    Active Devices : 2
   Working Devices : 2
    Failed Devices : 0
     Spare Devices : 0

        Chunk Size : 512K

Consistency Policy : none

              Name : localhost.localdomain:0  (local to host localhost.localdomain)
              UUID : 98cffedb:dd23fd6d:07b60209:b92643bd
            Events : 0

    Number   Major   Minor   RaidDevice State
       0       8       17        0      active sync   /dev/sdb1
       1       8       33        1      active sync   /dev/sdc1
```
       
       
#### Bước 5: Tạo file system (ext4) cho thiết bị RAID /dev/md0

```
[root@localhost ~]#  mkfs.ext4 /dev/md0
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=128 blocks, Stripe width=256 blocks
1310720 inodes, 5237760 blocks
261888 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=2153775104
160 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
	4096000

Allocating group tables: done
Writing inode tables: done
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done
```

* Tiếp theo tạo thư mục gắn kết `raid0` để gắn thiết bị `/dev/md0` thực hiện như bên dưới.

```
[root@localhost ~]# mkdir raid0
[root@localhost ~]# mount /dev/md0 raid0/
```

* Tiếp theo, chạy lệnh `df` để kiểm tra xem thiết bị `/dev/md0` được gắn trong thư mục `/root/raid0` không.

```
[root@localhost ~]# df -h
Filesystem           Size  Used Avail Use% Mounted on
/dev/mapper/cl-root   17G  1.3G   16G   8% /
devtmpfs             475M     0  475M   0% /dev
tmpfs                487M     0  487M   0% /dev/shm
tmpfs                487M  7.7M  479M   2% /run
tmpfs                487M     0  487M   0% /sys/fs/cgroup
/dev/sda1           1014M  201M  814M  20% /boot
tmpfs                 98M     0   98M   0% /run/user/0
/dev/md0             9.8G   37M  9.2G   1% /root/raid0
```

* Tạo một tệp `raid0/test0.txt`, thêm nội dung vào tệp đã tạo và xem nội dung của tệp.

```
[root@localhost ~]# ls -l raid0/
total 20
drwx------. 2 root root 16384 May 19 13:36 lost+found
[root@localhost ~]# echo "This is RAID0" > raid0/test0.txt
[root@localhost ~]# cat raid0/test0.txt
This is RAID0
```
Thiết bị `/dev/md0` gắn kết của chúng ta là tạm thời. Nếu hệ điều hành được khởi động lại, các thư mục được gắn kết này sẽ bị mất. Vì vậy, chúng ta cần phải gắn kết vĩnh viễn. Để thực hiện gắn kết vĩnh viễn phải nhập trong tệp `/etc/fstab`. Bạn có thể sử dụng trình soạn thảo vi để nhập dòng bên dưới vào:

```
/dev/md0        raid0   ext4    defaults        0 0
```

* Thực hiện như sau:

```
[root@localhost ~]# vi /etc/fstab

#
# /etc/fstab
# Created by anaconda on Tue May 14 10:34:53 2019
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/cl-root     /                       xfs     defaults        0 0
UUID=58253f4e-01e2-47c8-8f0c-49a1e5b0b7bf /boot                   xfs     defaults        0 0
/dev/mapper/cl-swap     swap                    swap    defaults        0 0
/dev/md0        raid0   ext4    defaults        0 0
```

* Lưu lại file /etc/fstab và chạy lệnh:

```
[root@localhost ~]# mount -a
[root@localhost ~]# mount -av
/                        : ignored
/boot                    : already mounted
swap                     : ignored
raid0                    : already mounted
```

Nếu có lỗi, không reboot server để tránh tình trạng server không thể khởi động. Kiểm tra cấu hình trong file `/etc/fstab` và chạy lại lệnh cho tới khi không có thông báo lỗi.

#### Bước 6: Lưu cấu hình RAID

Lưu cấu hình RAID vào một tệp để giữ cấu hình để sử dụng trong tương lai.

Chúng ta sử dụng lệnh `mdadm` với các tùy chọn `-s`(quét) và `-v` (dài dòng) như sau:

```
[root@localhost ~]# mdadm -E -s -v >> /etc/mdadm.conf
[root@localhost ~]# cat /etc/mdadm.conf
ARRAY /dev/md/0  level=raid0 metadata=1.2 num-devices=2 UUID=98cffedb:dd23fd6d:07b60209:b92643bd name=localhost.localdomain:0
   devices=/dev/sdc1,/dev/sdb1
```

* Qua các bước trên chúng ta đã tạo thành công RAID0 trên Centos7. 
# LMV
* Logical Volume Management(LVM) dùng quản lí các thiết bị lưu trữ .LVM là một tiện ích cho phép chia không gian đĩa cứng thành những Logical Volume từ đó giúp cho việc thay đổi kích thước trở nên dễ dàng.

* Ưu điểm của LVM là tăng tính linh hoạt và khả năng kiểm soát. Các tập có thể được thay đổi kích thước động khi yêu cầu không gian thay đổi và di chuyển giữa các thiết bị vật lý trong nhóm trên hệ thống đang chạy hoặc xuất dễ dàng. LVM cũng cung cấp các tính năng nâng cao như Backup hệ thống bằng cách snapshot các phân vùng ổ cứng(real-time), Migrate dữ liệu dễ dàng.

* LVM hiện có 2 phiên bản cho hệ điều hành Linux:

	* LVM 1: Phiên bản nằm trong kernel 2.4 series
	* LVM 2: Phiên bản mới nhất và lớn nhất của LVM cho Linux. LVM 2 sử dụng trình điều khiển kernel mapper.
## Cấu trúc quản lí lưu trữ LVM
* Chức năng **LVM** bằng cách xếp các lớp lên trên các thiết bị lưu trữ vật lý. Các lớp cơ bản mà **LVM** sử dụng:

	* **Physical Volume(pv)**: Ổ cứng vật lý (đĩa cứng, partition, SSD…) có thể chia thành nhiều phân vùng vật lý
	* **Volume Group(vg):** Là một nhóm bao gồm các **Physical Volume** trên 1 hoặc nhiều ổ đĩa khác nhau được kết hợp lại thành một **Volume Group**
	* **Logical Volume(lv)**: Một Volume Group được chia nhỏ thành nhiều Logical Volume. Nó được dùng cho các để mount tới hệ thống tập tin (File System) và được format với những chuẩn định dạng khác nhau như ext2, ext3, ext4…
Tóm lại, **LVM** có thể được sử dụng để kết hợp các **Physical Volume** thành các **Volume Group** để thống nhất không gian lưu trữ có sẵn trên một hệ thống. Sau đó, quản trị viên có thể phân **Volume Group** thành các **Logical Volume** tùy ý, hoạt động như các phân vùng.
## Các bước để quản lý và tạo LVM bằng các lệnh vgcreate, lvcreate và lvextend
### Tạo Physical Volume, Volume Group, và Logical Volume
#### Tạo Physical Volume
* Chạy lệnh sau để tạo physical volume(PV) trên `/dev/sdb`, `/dev/sdc`, và `/dev/sdd`

```
[root@localhost ~]# pvcreate /dev/sdb /dev/sdc /dev/sdd
  Physical volume "/dev/sdb" successfully created.
  Physical volume "/dev/sdc" successfully created.
  Physical volume "/dev/sdd" successfully created.
```
  
* Để liệt kê các physical volume(PV) mới được tạo, chạy như sau:
```
[root@localhost ~]# pvs
  PV         VG Fmt  Attr PSize   PFree
  /dev/sda2  cl lvm2 a--  <19.00g     0
  /dev/sdb      lvm2 ---   10.00g 10.00g
  /dev/sdc      lvm2 ---   10.00g 10.00g
  /dev/sdd      lvm2 ---   10.00g 10.00g
```

* Ý nghĩa các trường của `pvs`:

	* PV: Đĩa được sử dụng
	* PFree: Kích thước đĩa vật lý (Kích thước PV)
* Để có được thông tin chi tiết về mỗi physical volume(PV), sử dụng lệnh sau: `pvdisplay`

Xem thông tin chi tiết về physical volume(PV) `/dev/sdb`. Chúng ta thực hiện như sau:

```
[root@localhost ~]# pvdisplay /dev/sdb
  "/dev/sdb" is a new physical volume of "10.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdb
  VG Name
  PV Size               10.00 GiB
  Allocatable           NO
  PE Size               0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               sprsx7-glR2-P7w3-40FG-Fzey-ad57-VTGhA2
```

* Tương tự cho `/dev/sdc` và `/dev/sdd`:

```
[root@localhost ~]# pvdisplay /dev/sdc
  "/dev/sdc" is a new physical volume of "10.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdc
  VG Name
  PV Size               10.00 GiB
  Allocatable           NO
  PE Size               0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               HBbxa9-pepX-Dr5z-B4fJ-lTSb-JcfV-me7Wwo
[root@localhost ~]# pvdisplay /dev/sdd
  "/dev/sdd" is a new physical volume of "10.00 GiB"
  --- NEW Physical volume ---
  PV Name               /dev/sdd
  VG Name
  PV Size               10.00 GiB
  Allocatable           NO
  PE Size               0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               7cGgRT-DVBS-Kz0x-LIiB-qzN8-bvxl-HYxKdl
```

* Lưu ý: Nếu chúng ta có 2 ổ đĩa hay nhiều ổ đĩa để tạo một volume mà một đĩa ở volume bị mất thì dẫn tới volume đó mất luôn, vì thế phải chạy LVM trên RAID hoặc dùng tính năng RAID của LVM để có khả năng dung lỗi.

#### Tạo Volume Group

* Để tạo volume group với tên `vg0` bằng cách sử dụng `/dev/sdb` và `/dev/sdc`. Chúng ta thực hiện như sau:

```
[root@localhost ~]# vgcreate vg0 /dev/sdb /dev/sdc
  Volume group "vg0" successfully created
```

* Thực hiện lệnh sau để xem thông tin volume group vừa tạo:

```
[root@localhost ~]# vgdisplay vg0
  --- Volume group ---
  VG Name               vg0
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               19.99 GiB
  PE Size               4.00 MiB
  Total PE              5118
  Alloc PE / Size       0 / 0
  Free  PE / Size       5118 / 19.99 GiB
  VG UUID               3M10Re-sNdU-3UGY-h4WO-IXV1-pOW7-NUBOBC
```

* Vì **vg0** chứa hai đĩa 10GB nên VG Size = 19.99GB

* Ý nghĩa các thông tin của Volume group khi chạy lệnh `vgdisplay`:

	* VG Name: Tên Volume Group.
	* Format: Kiến trúc LVM được sử dụng.
	* VG Access: Volume Group có thể đọc và viết và sẵn sàng để sử dụng.
	* VG Status: Volume Group có thể được định cỡ lại, chúng ta có thể mở rộng thêm nếu cần thêm dung lượng.
	* PE Size: Mở rộng Physical, Kích thước cho đĩa có thể được xác định bằng kích thước PE hoặc GB, 4MB là kích thước PE mặc định của LVM
	* Total PE: Dung lượng Volume Group có
	* Alloc PE: Tổng PE đã sử dụng
	* Free PE: Tổng PE chưa được sử dụng
* Chúng ta có thể kiểm tra số lượng physical volume(PV) dùng để tạo volume group như sau:

```
[root@localhost ~]# vgs
  VG   #PV #LV #SN Attr   VSize   VFree
  cl     1   2   0 wz--n- <19.00g     0
  vg0   2   0   0 wz--n-  19.99g 19.99g
```

* Trong đó:

	* VG: Tên Volume Group
	* #PV: Physical Volume sử dụng trong Volume Group
	* VFree: Hiển thị không gian trống có sẵn trong Volume Group
	* VSize: Tổng kích thước của Volume Group
	* #LV: Logical Volume nằm trong volume group
	* #SN: Số lượng Snapshot của volume group
	* Attr: Trạng thái của Volume group có thể ghi, có thể đọc, có thể thay đổi,
* Khi tạo ra các logical volume, chúng ta cần phải xem xét dung lượng khi tạo logical volume sau cho phù hợp với nhu cầu sử dụng.

#### Tạo Logical Volume
* Chúng ta sẽ tạo 2 logical volume với tên `projects` có dung lượng là 10GB và `backups` sử dụng toàn bộ dung lượng còn lại của volume group. Chúng ta chạy lệnh sau:

```
[root@localhost ~]# lvcreate -n projects -L 10G vg0
  Logical volume "projects" created.
[root@localhost ~]# lvcreate -n backups -l 100%FREE vg0
  Logical volume "backups" created.
```
* Trong đó:

	* -n: Sử dụng chỉ ra tên của logical volume cần tạo.
	* -L: Sử dụng chỉ một kích thước cố định.
	* -l: Sử dụng chỉ phần trăm của không gian còn lại trong volume group.
* Chạy lệnh sau để xem danh sách logical volume vừa được tạo:
```
[root@localhost ~]# lvs
  LV           VG   Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  root         cl   -wi-ao---- <17.00g
  swap         cl   -wi-a-----   2.00g
  backups      vg0  -wi-a-----   9.99g
  projects     vg0  -wi-a-----  10.00g
```
* Ý nghĩa các trường của `lvs`:

	* LV: Tên logical volume
	* %Data: Phần trăm dung lượng logical volume được sử dụng
	* Lsize: Kích thước của logical volume
* Sử dụng lệnh sau để hiển thị thông tin chi tiết của các logical volume:

```
[root@localhost ~]# lvdisplay vg0/projects
  --- Logical volume ---
  LV Path                /dev/vg0/projects
  LV Name                projects
  VG Name                vg0
  LV UUID                zGbCrQ-FyrO-EjPu-cE5N-7JmQ-ECxt-kJuuFJ
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2019-04-14 20:14:30 +0700
  LV Status              available
  # open                 0
  LV Size                10.00 GiB
  Current LE             2560
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:2

[root@localhost ~]# lvdisplay vg0/backups
  --- Logical volume ---
  LV Path                /dev/vg0/backups
  LV Name                backups
  VG Name                vg0
  LV UUID                Hdk7t7-OyYj-q5gn-kNla-1cM5-rDCH-6FCmph
  LV Write Access        read/write
  LV Creation host, time localhost.localdomain, 2019-04-14 20:14:41 +0700
  LV Status              available
  # open                 0
  LV Size                9.99 GiB
  Current LE             2558
  Segments               1
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:3
```

* Chúng tôi sẽ sử dụng file system `ext4` vì nó cho phép chúng ta tăng và giảm kích thước của mỗi logical volume (với file system `xfs` chỉ cho phép tăng kích thước). Chúng ta thực hiện như sau:

```
[root@localhost ~]# mkfs.ext4 /dev/vg0/projects
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
655360 inodes, 2621440 blocks
131072 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=2151677952
80 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632

Allocating group tables: done
Writing inode tables: done
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done

[root@localhost ~]# mkfs.ext4 /dev/vg0/backups
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
655360 inodes, 2619392 blocks
130969 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=2151677952
80 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632

Allocating group tables: done
Writing inode tables: done
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done
```

### Mở rộng Volume Group và thay đổi kích thước các Logical Volume
* Trong ví dụ dưới đây chúng ta sẽ thêm một physical volume có tên `/dev/sdd` với kích thước 10GB vào volume group vg0, sau đó chúng ta sẽ tăng kích thước của logical volume `/projects` lên 10GB thực hiện như sau:

Chạy các lệnh sau để tạo điểm gắn kết:

```
[root@localhost ~]# mkdir /projects
[root@localhost ~]# mkdir /backups
```
Chạy lệnh sau để mount:

```
[root@localhost ~]# mount /dev/vg0/projects /projects/
[root@localhost ~]# mount /dev/vg0/backups /backups/
```
Chạy lệnh sau kiểm tra sử dụng không gian đĩa hệ thống tập tin:

```
[root@localhost ~]# df -TH
Filesystem               Type      Size  Used Avail Use% Mounted on
/dev/mapper/cl-root      xfs        19G  1.1G   18G   6% /
devtmpfs                 devtmpfs  501M     0  501M   0% /dev
tmpfs                    tmpfs     512M     0  512M   0% /dev/shm
tmpfs                    tmpfs     512M  7.1M  505M   2% /run
tmpfs                    tmpfs     512M     0  512M   0% /sys/fs/cgroup
/dev/sda1                xfs       1.1G  145M  919M  14% /boot
tmpfs                    tmpfs     103M     0  103M   0% /run/user/0
/dev/mapper/vg0-projects ext4      11G   38M   9.9G   1% /projects
/dev/mapper/vg0-backups  ext4      11G   38M   9.9G   1% /backups
```

* Sử dụng lệnh sau để thêm /dev/sdd vào volume group vg0:

```
[root@localhost ~]# vgextend vg0 /dev/sdd
  Volume group "vg0" successfully extended
```
* Chúng ta chạy lệnh `vgdisplay vg0` trước và sau khi thực hiện lệnh `vgextend vg0 /dev/sdd`, bạn sẽ thấy sự tăng kích thước của volume group(VG):

Trước khi chạy lệnh vgextend vg0 /dev/sdd

```
[root@localhost ~]# vgdisplay vg0
  --- Volume group ---
  VG Name               vg0
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  3
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                2
  Open LV               2
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               19.99 GiB
  PE Size               4.00 MiB
  Total PE              5118
  Alloc PE / Size       5118 / 19.99 GiB
  Free  PE / Size       0 / 0
  VG UUID               3M10Re-sNdU-3UGY-h4WO-IXV1-pOW7-NUBOBC
```
* Sau khi chạy lệnh vgextend vg0 /dev/sdd

```
[root@localhost ~]# vgdisplay vg0
  --- Volume group ---
  VG Name               vg0
  System ID
  Format                lvm2
  Metadata Areas        3
  Metadata Sequence No  6
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                2
  Open LV               0
  Max PV                0
  Cur PV                3
  Act PV                3
  VG Size               <29.99 GiB
  PE Size               4.00 MiB
  Total PE              7677
  Alloc PE / Size       5118 / 19.99 GiB
  Free  PE / Size       2559 / <10.00 GiB
  VG UUID               3M10Re-sNdU-3UGY-h4WO-IXV1-pOW7-NUBOBC
 ```
* Qua lệnh kiểm tra trên chúng ta thấy dung lượng thêm vào của chúng ta là 10GB chúng ta có thể tăng kích thước của logical volume `/projects` lên 10GB thực hiện như sau:

```
[root@localhost ~]# lvextend -l +2000 /dev/vg0/projects
  Size of logical volume vg0/projects changed from 10.00 GiB (1920 extents) to 17.81 GiB (4560 extents).
  Logical volume vg0/projects successfully resized.
```

* Sau khi chạy lệnh trên chúng ta cần thay đổi kích thước hệ thống tệp, vì thế chúng ta phải chạy lệnh sau để resize:

	* Đối với file system (ext2, ext3, ext 4): resize2fs.
	* Đối với file system (xfs): `xfs_growfs`.

```
[root@localhost ~]# resize2fs /dev/vg0/projects
resize2fs 1.42.9 (28-Dec-2013)
Filesystem at /dev/vg0/projects is mounted on /projects; on-line resizing required
old_desc_blocks = 1, new_desc_blocks = 2
The filesystem on /dev/vg0/projects is now 4669440 blocks long.

[root@localhost ~]# df -TH
Filesystem               Type      Size  Used Avail Use% Mounted on
/dev/mapper/cl-root      xfs        19G  1.1G   18G   6% /
devtmpfs                 devtmpfs  501M     0  501M   0% /dev
tmpfs                    tmpfs     512M     0  512M   0% /dev/shm
tmpfs                    tmpfs     512M  7.1M  505M   2% /run
tmpfs                    tmpfs     512M     0  512M   0% /sys/fs/cgroup
/dev/sda1                xfs       1.1G  145M  919M  14% /boot
tmpfs                    tmpfs     103M     0  103M   0% /run/user/0
/dev/mapper/vg0-projects ext4       19G   47M   18G   1% /projects
/dev/mapper/vg0-backups   ext4       11G   38M  9.9G   1% /backups
```

### Giảm kích cỡ Logical Volume
* Khi chúng ta muốn giảm dung lượng các Logical Volume. Chúng ta cần phải chú ý vì nó rất quan trọng và có thể bị lỗi trong khi chúng ta giảm dung lượng Logical Volume. Để đảm bảo an toàn khi giảm Logical Volume cần thực hiện các bước sau:

	* Trước khi bắt đầu, cần sao lưu dữ liệu vì vậy sẽ không phải đau đầu nếu có sự cố xảy ra.
	* Để giảm dung lượng Logical Volume, cần thực hiện đầy đủ và cẩn thận 5 bước cần thiết.
	* Khi giảm dung lượng Logical Volume chúng ta phải ngắt kết nối hệ thống tệp trước khi giảm.
Cần thực hiện cẩn thận 5 bước dưới đây:

	* Ngắt kết nối file system.
	* Kiểm tra file system sau khi ngắt kết nối.
	* Giảm file system.
	* Giảm kích thước Logical Volume hơn kích thước hiện tại.
	* Kiểm tra lỗi cho file system.
	* Mount lại file system và kiểm tra kích thước của nó.
* Ví dụ: Giảm Logical Volume có tên `project` với kích thước từ 17.81GB giảm xuống còn 10GB mà không làm mất dữ liệu. Chúng ta thực hiện các bước như sau:

Kiểm tra dung lượng của Logical Volume và kiểm tra file system trước khi thực hiện giảm:

```
[root@localhost ~]# lvs
  LV       VG  Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  root     cl  -wi-ao---- 17.00g
  swap     cl  -wi-ao----  2.00g
  backups  vg0 -wi-ao---- 10.00g
  projects vg0 -wi-ao---- 17.81g
[root@localhost ~]# df -TH
Filesystem               Type      Size  Used Avail Use% Mounted on
/dev/mapper/cl-root      xfs        19G  6.8G   12G  37% /
devtmpfs                 devtmpfs  501M     0  501M   0% /dev
tmpfs                    tmpfs     512M     0  512M   0% /dev/shm
tmpfs                    tmpfs     512M  7.1M  505M   2% /run
tmpfs                    tmpfs     512M     0  512M   0% /sys/fs/cgroup
/dev/sda1                xfs       1.1G  145M  919M  14% /boot
tmpfs                    tmpfs     103M     0  103M   0% /run/user/0
/dev/mapper/vg0-projects ext4       19G  4.4G   14G  25% /projects
/dev/mapper/vg0-backups  ext4       11G  4.4G  5.6G  44% /backups
```

* Bước 1: Umount file system

Sử dụng lệnh `umount` bên dưới:

```
[root@localhost ~]# umount /projects/
[root@localhost ~]# df -TH
Filesystem              Type      Size  Used Avail Use% Mounted on
/dev/mapper/cl-root     xfs        19G  6.8G   12G  37% /
devtmpfs                devtmpfs  501M     0  501M   0% /dev
tmpfs                   tmpfs     512M     0  512M   0% /dev/shm
tmpfs                   tmpfs     512M  7.1M  505M   2% /run
tmpfs                   tmpfs     512M     0  512M   0% /sys/fs/cgroup
/dev/sda1               xfs       1.1G  145M  919M  14% /boot
tmpfs                   tmpfs     103M     0  103M   0% /run/user/0
/dev/mapper/vg0-backups ext4       11G  4.4G  5.6G  44% /backups
```

* Bước 2: Kiểm tra lỗi file system bằng lệnh e2fsck.

```
[root@localhost ~]# e2fsck -f /dev/vg0/projects
e2fsck 1.42.9 (28-Dec-2013)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/vg0/projects: 11/1171456 files (0.0% non-contiguous), 117573/4669440 blocks
```

Trong đó tùy chọn `-f` dùng để kiểm tra(force check).

* Bước 3: Giảm kích thước của `projects` theo kích thước mong muốn.

Giảm Logical Volume có tên `projects` với kích thước từ 17.81GB giảm xuống còn 10GB chúng ta thực hiện như sau:

```
[root@localhost ~]# resize2fs /dev/vg0/projects 10G
resize2fs 1.42.9 (28-Dec-2013)
Resizing the filesystem on /dev/vg0/projects to 2621440 (4k) blocks.
The filesystem on /dev/vg0/projects is now 2621440 blocks long.
```

Bước 4: Bây giờ giảm kích thước bằng lệnh `lvreduce`.

```
[root@localhost ~]# lvreduce -L 10G /dev/vg0/projects
  WARNING: Reducing active logical volume to 10.00 GiB.
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce vg0/projects? [y/n]: y
  Size of logical volume vg0/projects changed from 17.81 GiB (4560 extents) to 10.00 GiB (2560 extents).
  Logical volume vg0/projects successfully resized.
```

* Bước 5: Để đảm bảo an toàn, bây giờ kiểm tra lỗi file system đã giảm

```
[root@localhost ~]# e2fsck -f /dev/vg0/projects
e2fsck 1.42.9 (28-Dec-2013)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/vg0/projects: 11/655360 files (0.0% non-contiguous), 83137/2621440 blocks
```

* Bước 6: Gắn kết file system và kiểm tra kích thước của nó.

```
[root@localhost ~]# mount /dev/vg0/projects /projects/
[root@localhost ~]# lvs
  LV       VG  Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  root     cl  -wi-ao---- 17.00g
  swap     cl  -wi-ao----  2.00g
  backups  vg0 -wi-ao---- 10.00g
  projects vg0 -wi-ao---- 10.00g
[root@localhost ~]# df -TH
Filesystem               Type      Size  Used Avail Use% Mounted on
/dev/mapper/cl-root      xfs        19G  6.8G   12G  37% /
devtmpfs                 devtmpfs  501M     0  501M   0% /dev
tmpfs                    tmpfs     512M     0  512M   0% /dev/shm
tmpfs                    tmpfs     512M  7.1M  505M   2% /run
tmpfs                    tmpfs     512M     0  512M   0% /sys/fs/cgroup
/dev/sda1                xfs       1.1G  145M  919M  14% /boot
tmpfs                    tmpfs     103M     0  103M   0% /run/user/0
/dev/mapper/vg0-backups  ext4       11G  4.4G  5.6G  44% /backups
/dev/mapper/vg0-projects ext4       11G  4.4G  5.6G  44% /projects
```
### Mounting Logical Volume
* Chúng ta cần phải gắn kết vĩnh viễn. Để thực hiện gắn kết vĩnh viễn phải nhập trong tệp /etc/fstab. Bạn có thể sử dụng trình soạn thảo vi để nhập vào:
```
[root@localhost ~]# vim /etc/fstab

#
# /etc/fstab
# Created by anaconda on Thu Apr 11 21:36:46 2019
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/cl-root     /                       xfs     defaults        0 0
UUID=8c1d2c4f-13d0-4ec9-ae3d-f706311400ad /boot                   xfs     defaults        0 0

UUID=3fe80222-0f42-4d34-8ce7-e4f51c3a7f61 /backups ext4 defaults 0 0
UUID=314f59be-2c3c-4ded-bc3e-cd79544ef1ee /projects ext4 defaults 0 0
```

* Để xác định UUID trên mỗi đĩa. Chúng ta chạy lệnh sau:

```
[root@localhost ~]# blkid /dev/vg0/projects
/dev/vg0/projects: UUID="314f59be-2c3c-4ded-bc3e-cd79544ef1ee" TYPE="ext4"
[root@localhost ~]# blkid /dev/vg0/backups
/dev/vg0/backups: UUID="3fe80222-0f42-4d34-8ce7-e4f51c3a7f61" TYPE="ext4"
```

* Khi đã biết UUID và hệ thống tệp, chúng tôi có thể nhập vào tệp /etc/fstab. Các tập tin fstab có định dạng sau.

```
[Device] [Mount Point] [File System Type] [Options] [Dump] [Pass]
Lưu lại file /etc/fstab và chạy lệnh sau lưu các thay đổi và gắn kết LV:

[root@localhost ~]# mount -a
[root@localhost ~]# mount | grep backups
/dev/mapper/vg0-backups on /backups type ext4 (rw,relatime,seclabel,data=ordered)
[root@localhost ~]# mount | grep projects
/dev/mapper/vg0-projects on /projects type ext4 (rw,relatime,seclabel,data=ordered)
```
* Nếu có lỗi, không reboot server để tránh tình trạng server không thể khởi động. Kiểm tra cấu hình trong file `/etc/fstab` và chạy lại lệnh cho tới khi không có thông báo lỗi.
# Linux File Hierarchy Structure ( Cấu trúc phân cấp tệp Linux )
* Cấu trúc phân cấp tệp của Linux hoặc Tiêu chuẩn phân cấp hệ thống tệp (FHS) xác định cấu trúc thư mục và nội dung thư mục trong hệ điều hành giống Unix. Nó được duy trì bởi Linux Foundation.
	* Trong FHS, tất cả các tệp và thư mục xuất hiện trong thư mục gốc /, ngay cả khi chúng được lưu trữ trên các thiết bị vật lý hoặc ảo khác nhau.
	* Một số thư mục này chỉ tồn tại trên một hệ thống cụ thể nếu một số hệ thống con nhất định, chẳng hạn như Hệ thống Cửa sổ X, được cài đặt.
	* Hầu hết các thư mục này tồn tại trong tất cả các hệ điều hành UNIX và thường được sử dụng theo cùng một cách; tuy nhiên, các mô tả ở đây là những mô tả được sử dụng riêng cho FHS và không được coi là có thẩm quyền cho các nền tảng khác ngoài Linux.
![image](https://user-images.githubusercontent.com/91528234/199213809-07311497-d34e-41a6-b27d-567deda1740d.png)
## /(Root):
* Thư mục gốc phân cấp chính và thư mục gốc của toàn bộ hệ thống tập tin phân cấp.

* Mọi tệp và thư mục đều bắt đầu từ thư mục gốc

* Người dùng root duy nhất có quyền viết trong thư mục này

* /root là thư mục chính của người dùng root, không giống với /
![image](https://user-images.githubusercontent.com/91528234/199214078-f1d1868d-3770-43ce-a22c-0d02ff78cc86.png)
## /bin
* Các mã nhị phân lệnh cần thiết cần có sẵn trong chế độ một người dùng; cho tất cả người dùng, ví dụ: cat, ls, cp. 
* Chứa các tệp thực thi nhị phân
* Common linux commands you need to use in single-user modes are located under this directory.
* Commands used by all the users of the system are located here e.g. ps, ls, ping, grep, cp
![image](https://user-images.githubusercontent.com/91528234/199214298-f8afff4d-cb18-4511-8803-b929d6ba22ef.png)
## /boot
* file boot loader VD: kernels, initrd.
* Các tệp initrd, vmlinux, grub hạt nhân nằm trong /boot
* Ví dụ: initrd.img-2.6.32-24-generic, vmlinuz-2.6.32-24-generic
![image](https://user-images.githubusercontent.com/91528234/199215029-1325f59d-f4e8-4257-93c3-2a41606c2e9f.png)

## /dev 
* Các tệp thiết bị cần thiết, ví dụ: /dev/null.
* Chúng bao gồm các thiết bị đầu cuối, usb hoặc bất kỳ thiết bị nào được gắn vào hệ thống.
* Ví dụ: /dev/tty1, /dev /usbmon0
![image](https://user-images.githubusercontent.com/91528234/199215233-8e88fd21-6e28-4399-9aa4-8c1b55ed12f5.png)
## /etc
* Tệp cấu hình toàn hệ thống dành riêng cho máy chủ.
* Chứa các tệp cấu hình được yêu cầu bởi tất cả các chương trình.
* Điều này cũng chứa các kịch bản trình bao khởi động và tắt máy được sử dụng để khởi động / dừng các chương trình riêng lẻ.
* Ví dụ: /etc/resolv.conf, /etc/logrotate.conf.
![image](https://user-images.githubusercontent.com/91528234/199215552-27addabf-3954-4645-a816-388613b2f321.png)
## /home
* Thư mục chính của người dùng, chứa các tệp đã lưu, cài đặt cá nhân, v.v.
* Thư mục chính cho tất cả người dùng để lưu trữ các tệp cá nhân của họ.
* ví dụ: /home/kishlay, /home/sonpt

![image](https://user-images.githubusercontent.com/91528234/199216083-0f55bb03-e2fc-4711-b845-44f75f55bc07.png)

![image](https://user-images.githubusercontent.com/91528234/199215914-113b72af-a061-4395-848b-404a72fffaac.png)
## /lib
* Các thư viện cần thiết cho các mã nhị phân trong /bin/ và /sbin/.
* Tên tệp thư viện là ld * hoặc lib * .so. *
* Ví dụ: ld-2.11.1.so, libncurses.so.5.7
![image](https://user-images.githubusercontent.com/91528234/199216248-1db6c4b5-6910-467d-92f5-cbc92c066856.png)

## /media
* Gắn các điểm cho phương tiện di động như CD-ROM (xuất hiện trong FHS-2.3).

* Thư mục mount tạm thời cho các thiết bị di động.

* Ví dụ, /media/cdrom cho CD-ROM; /media/floppy cho ổ đĩa mềm; /media/cdrecorder cho đầu ghi CD
## /mnt
* Hệ thống tệp được gắn kết tạm thời.
* Thư mục mount tạm thời nơi sysadmins có thể mount các hệ thống tập tin
![image](https://user-images.githubusercontent.com/91528234/199216715-b3202ca5-80e8-444b-9e2d-673d1d43880d.png)
## /opt
* Các gói phần mềm ứng dụng tùy chọn.
* Chứa các ứng dụng bổ trợ từ các nhà cung cấp riêng lẻ.
* Các ứng dụng bổ trợ phải được cài đặt trong thư mục con /opt/ hoặc /opt/.
* ![image](https://user-images.githubusercontent.com/91528234/199216874-5cf96f14-9584-4fe9-b956-95a1a13f337b.png)
## /sbin
* Hệ thống nhị phân thiết yếu, ví dụ: fsck, init, route.
* Cũng giống như /bin, /sbin cũng chứa các tệp thực thi nhị phân.
* Các lệnh linux nằm trong thư mục này thường được quản trị viên hệ thống sử dụng cho mục đích bảo trì hệ thống.
* Ví dụ: iptables, reboot, fdisk, ifconfig, swapon
![image](https://user-images.githubusercontent.com/91528234/199217305-27744a35-1946-4d85-bf83-526efe58f9b3.png)

## /srv 
* Dữ liệu dành riêng cho trang web được cung cấp bởi hệ thống này, chẳng hạn như dữ liệu và tập lệnh cho máy chủ web, dữ liệu do máy chủ FTP cung cấp và kho lưu trữ cho hệ thống kiểm soát phiên bản.
* srv là viết tắt của dịch vụ.
* Chứa dữ liệu liên quan đến dịch vụ cụ thể của máy chủ.
* Ví dụ, /srv/cvs chứa dữ liệu liên quan đến CVS.
![image](https://user-images.githubusercontent.com/91528234/199217583-9511ee0e-fe20-45b6-a17e-3be9eacbffa3.png)
## /tmp
* Hồ sơ tạm thời. Thường không được bảo toàn giữa các lần khởi động lại hệ thống và có thể bị giới hạn kích thước nghiêm trọng.
* Thư mục chứa các tệp tạm thời được tạo bởi hệ thống và người dùng.
* Các tệp trong thư mục này sẽ bị xóa khi hệ thống được khởi động lại.
![image](https://user-images.githubusercontent.com/91528234/199217747-92cbd671-18d4-41bb-96a8-3bcc0d2ac8af.png)
## /usr
* Hệ thống phân cấp thứ cấp cho dữ liệu người dùng chỉ đọc; chứa phần lớn (nhiều) tiện ích và ứng dụng người dùng.
* Chứa các tệp nhị phân, thư viện, tài liệu và mã nguồn cho các chương trình cấp hai.
* /usr/bin chứa các tệp nhị phân cho các chương trình người dùng. Nếu bạn không thể tìm thấy tệp nhị phân người dùng trong / bin, hãy xem trong /usr/bin. Ví dụ: at, awk, cc, less, scp
* /usr/sbin chứa các tệp nhị phân dành cho quản trị viên hệ thống. Nếu bạn không thể tìm thấy mã nhị phân hệ thống trong /sbin, hãy xem trong /usr/sbin. Ví dụ: atd, cron, sshd, useradd, userdel
* /usr/lib chứa các thư viện cho /usr/bin và /usr/sbin
* / usr / local chứa các chương trình người dùng mà bạn cài đặt từ nguồn. Ví dụ: khi bạn cài đặt apache từ nguồn, nó sẽ nằm dưới /usr/local/apache2
* /usr/src chứa các nguồn nhân Linux, tệp tiêu đề và tài liệu.
![image](https://user-images.githubusercontent.com/91528234/199218097-41bf04bc-7da6-4b36-a5c0-8792b12a7a33.png)
## /proc
* Hệ thống tệp ảo cung cấp quy trình và thông tin hạt nhân dưới dạng tệp. Trong Linux, tương ứng với một procfs mount. Nói chung được tạo tự động và được hệ thống điền vào một cách nhanh chóng.
* Chứa thông tin về quy trình hệ thống.
* Đây là một hệ thống tập tin giả chứa thông tin về quá trình đang chạy. Ví dụ: thư mục /proc/{pid} chứa thông tin về quy trình với pid cụ thể đó.
* Đây là một hệ thống tệp ảo với thông tin văn bản về tài nguyên hệ thống. Ví dụ: /proc/uptime
![image](https://user-images.githubusercontent.com/91528234/199218324-4e58c4a9-2760-4845-9e64-50a5d098184a.png)
# Managing Files and Link
## Lệnh ls
* Chạy lệnh ls mà không có tệp danh sách tùy chọn và thư mục ở định dạng trống, nơi chúng tôi sẽ không thể xem các chi tiết như loại tệp, kích thước, ngày và giờ sửa đổi, quyền và liên kết, v.v.
![image](https://user-images.githubusercontent.com/91528234/199385801-4fb6bdb7-32af-4e6a-84ab-baf75fc59279.png)

* Một vài option khác

|OPTION| ACTION |
| :---- | :---- |
| -l | hiển thị tệp hoặc thư mục, kích thước, ngày và giờ sửa đổi, tên tệp hoặc thư mục và chủ sở hữu của tệp và quyền của tệp.|
| -a | Liệt kê tất cả các tệp bao gồm các tệp ẩn bắt đầu bằng ‘`.`‘. |
| -lh | hiển thị kích thước ở định dạng con người có thể đọc được. |
| -F | thêm ký tự '/' vào cuối mỗi thư mục.|
| -r | hiển thị các tệp và thư mục theo thứ tự ngược lại. |
| -R | liệt kê cây thư mục danh sách |
| -ltr | hiển thị tệp sửa đổi mới nhất hoặc ngày thư mục cuối cùng. |
| -LS | hiển thị kích thước tệp theo thứ tự, sẽ hiển thị kích thước lớn trước. |
| -i | liệt kê tệp / thư mục với một số inode |
## Lệnh cp
* Thao tác sao chép-dán tệp mà không cần rời khỏi thiết bị đầu cuối. Trong một thiết bị đầu cuối dựa trên Linux, bạn thực hiện việc này bằng lệnh `cp`.
* Cú pháp câu lệnh
```
cp [...file/directory-sources] [destination]
```
* Trong đó 
	* [file/directory-sources] chỉ định nguồn của các tệp hoặc thư mục bạn muốn sao chép.
	* [destination] đối số chỉ định vị trí bạn muốn sao chép tệp vào.
## Lệnh mv
* Lệnh mv Linux được sử dụng để di chuyển tệp hoặc thư mục hiện có từ vị trí này sang vị trí khác. Nó cũng được sử dụng để đổi tên một tệp hoặc thư mục. Nếu bạn muốn đổi tên một thư mục hoặc tệp thì tùy chọn 'mv' sẽ tốt hơn để sử dụng.
```
mv [OPTION] ...
```
* một vài optin của `mv`

|OPTION| ACTION |
| :---- | :---- |
| -i | Yêu cầu quyền để ghi đè. |
| mv* | Di chuyển nhiều tệp vào một thư mục củ thể |
| --suffix | Được sử dụng để sao lưu trước khi ghi quá nhiều. |
| -u | Chỉ di chuyển những tệp không tồn tại.|
## Lệnh rm
* rm là viết tắt của remove ở đây. Lệnh rm được sử dụng để xóa các đối tượng như tệp, thư mục, liên kết tượng trưng,... khỏi hệ thống tệp như UNIX 
```
rm [OPTION]... FILE...
```
* một vài option của 'rm'

|OPTION| ACTION |
| :---- | :---- |
| -f, --force |	Bỏ qua các tệp không tồn tại và không bao giờ nhắc trước khi xóa. |
| -i |	Nhắc nhở trước mỗi lần loại bỏ.| 
| -I |	Nhắc một lần trước khi xóa nhiều hơn ba tệp hoặc khi xóa đệ quy. Tùy chọn này ít xâm nhập hơn **-i**, nhưng vẫn bảo vệ khỏi hầu hết các lỗi. |
|--interactive[=WHEN] |	Nhắc theo WHEN: không bao giờ, một lần (**-I**), hoặc luôn luôn (**-i**). Nếu WHEN không được chỉ định, thì hãy nhắc luôn. |
| --one-file-system |	Khi loại bỏ một hệ thống phân cấp một cách đệ quy, hãy bỏ qua bất kỳ thư mục nào nằm trên hệ thống tệp khác với hệ thống của đối số dòng lệnh tương ứng. |
| --no-preserve-root |	Không xử lý "/" (thư mục gốc) theo bất kỳ cách đặc biệt nào. |
| --preserve-root |	Không loại bỏ "/" (thư mục gốc), đó là hành vi mặc định. |
| -r, -R, --recursive |	Loại bỏ các thư mục và nội dung của chúng một cách đệ quy. |
| -d, --dir |	Loại bỏ các thư mục trống. Tùy chọn này cho phép bạn xóa một thư mục mà không chỉ định -r/-R/--recursive, miễn là thư mục đó trống. Nói cách khác, **rm -d** tương đương với việc sử dụng rmdir. |
## Lệnh touch
* Lệnh Touch Linux được dùng để tạo file trống, đổi timestampts của files và folders. Thông tin timestamps chứa 3 attribute – thời gian truy cập, thời gian sửa file, và thời gian thay đổi.
* Cú pháp lệnh touch command linux là:
```
touch [options] [file_name]
```
* Các option của `touch`

|OPTION| ACTION |
| :---- | :---- |
| -a | Đổi thời gian truy cập |
| -m | Đổi thời gian chỉnh sửa file |
| -am | Đổi thời gian truy cập và chỉnh sửa |
| -c | Đổi Access Time mà không phải tạo file |
| -t | Đặt thời gian nhất định cho thời gian truy cập và chỉnh sửa |
| -h | thay đổi timestamp của symbolic |
| -r | Đặt timestamp bằng cách dùng file khác tham chiếu |
## Lệnh ln
* Lệnh ln được sử dụng để tạo liên kết cứng và liên kết mềm cho các tệp trong Linux
```
ln [OPTION]... [-T] TARGET LINK_NAME   (1st form)
ln [OPTION]... TARGET... DIRECTORY     (2nd form)
ln [OPTION]... -t DIRECTORY TARGET...  (3rd form)
```
# Managing File Ownership: ‘chown’, ‘chgrp’
## Chown
* Lệnh chown của Linux được sử dụng để thay đổi quyền sở hữu tệp, thư mục hoặc liên kết tượng trưng cho người dùng hoặc nhóm. Chown là viết tắt của sự thay đổi chủ sở hữu. Trong Linux, mỗi tệp được liên kết với một chủ sở hữu hoặc nhóm tương ứng.

* Hệ thống Linux có thể có nhiều người dùng. Mỗi người dùng có một tên và ID người dùng duy nhất. Nếu chỉ có người dùng trong hệ thống, người dùng sẽ là chủ sở hữu của mỗi tệp.

* Hệ thống Linux có thể có nhiều người dùng. Mỗi người dùng có một tên và ID người dùng duy nhất. Nếu chỉ có người dùng trong hệ thống, người dùng sẽ là chủ sở hữu của mỗi tệp.

* Người dùng có thể được liệt kê trong các nhóm khác nhau. Nhóm cho phép chúng tôi đặt quyền ở cấp độ nhóm thay vì đặt quyền ở cấp độ cá nhân.
* Cú pháp như sau:
```
chown [OPTION]... [OWNER][:[GROUP]] FILE...  
```
|OPTION| ACTION |
| :---- | :---- |
| -c, --changes | Nó được sử dụng để hiển thị đầu ra chi tiết như dài dòng, nhưng nó được báo cáo khi chỉ có một thay đổi được thực hiện. |
| -f, --silent, --quiet | Nó được sử dụng để loại bỏ các thông báo lỗi. |
| -v, --verbose | Nó được sử dụng để hiển thị chẩn đoán cho mọi tệp đã xử lý. |
| --dereference | Nó được sử dụng để ảnh hưởng đến tham chiếu của mỗi liên kết tượng trưng. |
| -h, --no-dereference | Nó được sử dụng để ảnh hưởng đến các liên kết tượng trưng thay vì bất kỳ tệp được tham chiếu nào. |
| --from = CURRENT_OWNER:CURRENT_GROUP | Nó được sử dụng để thay đổi chủ sở hữu và nhóm cụ thể. |
|--no-secure-root | Đặc biệt được sử dụng để không xử lý dấu gạch chéo ngược ('/'). |
|--preserve-root | Nếu chown không hoạt động đệ quy trên dấu gạch chéo ngược ('/'). |
|--reference = RFILE | Nó được sử dụng để chỉ định chủ sở hữu và nhóm của RFILE thay vì giá trị của chúng. |
|-R, --recursive | Nó được sử dụng để thực hiện các thao tác trên tệp và thư mục một cách đệ quy. |
## Lệnh chgrp
* Lệnh chgrp của Linux được sử dụng để thay đổi quyền sở hữu nhóm của một tệp hoặc thư mục. Trong hệ thống tệp Linux, mỗi tệp có liên quan đến chủ sở hữu và nhóm tương ứng và có quyền đọc, ghi và thực thi.
* Cú pháp:
```
chgrp [OPTION]... GROUP FILE...  
chgrp [OPTION]... --reference=RFILE FILE... 
```
|OPTION| ACTION |
| :---- | :---- |
| -c, --changes | Nó giống như tùy chọn 'dài dòng' nhưng nó chỉ được báo cáo khi có thay đổi. |
| -f, --silent, --quiet | Nó được sử dụng để loại bỏ hầu hết các thông báo lỗi. |
| -v, --verbose | Nó được sử dụng để hiển thị chẩn đoán cho mọi tệp được xử lý. |
| --dereference | Nó được sử dụng để ảnh hưởng đến ý nghĩa của mỗi liên kết tượng trưng, ​​chứ không phải bản thân liên kết biểu tượng. |
| -h, --no-dereference | Nó được sử dụng để thay đổi các liên kết tượng trưng thay vì bất kỳ tệp được tham chiếu nào |
| --no-secure-root | Nó được sử dụng để không điều trị đặc biệt cho '/'. |
| --preserve-root | Nó được sử dụng khi lệnh mặc định không hoạt động đệ quy trên '/.' |
| --reference = RFILE | Nó được sử dụng để sử dụng nhóm của RFILE thay vì một nhóm cụ thể. |
| -R, --recursive | Nó được sử dụng để hoạt động trên các tệp và thư mục một cách đệ quy. Tùy chọn chỉ định chuyển ngang của tùy chọn '-R'. |
| -H | Nó được sử dụng để duyệt một liên kết tượng trưng đến một thư mục. |
| -L | Nó được sử dụng để duyệt qua mọi liên kết tượng trưng đến một thư mục gặp phải. |
| -P | Nếu tùy chọn này được chỉ định, nó sẽ không truyền qua bất kỳ liên kết tượng trưng nào (mặc định) |
# Controlling Access to Files: Understanding Permissions, ‘chmod’
* Lệnh chmod của Linux được sử dụng để thay đổi quyền truy cập của tệp và thư mục. Nó là viết tắt của chế độ thay đổi. Nó không thể thay đổi sự cho phép của các liên kết tượng trưng. Thậm chí, nó còn bỏ qua các liên kết tượng trưng đi qua đường truyền thư mục đệ quy.
* Trong hệ thống tệp Linux, mỗi tệp được liên kết với một chủ sở hữu cụ thể và có quyền truy cập cho những người dùng khác nhau. Các lớp người dùng có thể là:
	* owner
	* group member
	* Others (người dùng thường)
* Quyền đối với tệp trong Linux là ba loại sau:
	* read (r)
	* write (w)
	* execute (x)
* Cú pháp
```
chmod <options> <permissions> <file name>  
```
* Các option

|| ACTION |
| :---- | :---- |
| -c, | --changes | Nó tương tự như tùy chọn dài dòng, nhưng sự khác biệt là nó được báo cáo nếu một thay đổi đã được thực hiện. |
| -f, --silent, --quiet| Nó được sử dụng để loại bỏ các thông báo lỗi. |
| -v, --verbose | Nó được sử dụng để hiển thị chẩn đoán cho mọi tệp đã xử lý. |
| --no-secure-root | Nó được sử dụng để không xử lý biểu tượng dấu gạch chéo ngược ('/'), đặc biệt là (mặc định). |
| --preserve-root | Nếu tùy chọn này được sử dụng, nó sẽ không hoạt động đệ quy trên dấu gạch chéo ngược ('/').|
| --reference = RFILE | Nó được sử dụng để chỉ định chế độ của RFILE thay thế các giá trị MODE.|
| -R, --recursive | Nó được sử dụng để thay đổi các tệp và thư mục một cách đệ quy. |
## Tool for Locating Files
## Lệnh find
* Lệnh find giúp chúng ta tìm một tệp cụ thể trong một thư mục. Nó được sử dụng để tìm danh sách các tệp cho các điều kiện khác nhau như quyền, quyền sở hữu người dùng, sửa đổi, ngày / giờ, kích thước và hơn thế nữa.
* Tiện ích tìm kiếm đi kèm theo mặc định với hầu hết các bản phân phối Linux, vì vậy chúng tôi không cần cài đặt bất kỳ gói bổ sung nào. Đây là một trong những lệnh cần thiết và được sử dụng nhiều nhất của hệ thống Linux.
```
find <location> <comparison-criteria> <search-term>  
```
* Các ký hiệu sau được sử dụng để chỉ định thư mục:

	* (.): Cho tên thư mục hiện tại

	* (/): Dành cho thư mục gốc
### Tìm kiếm file theo tên
* Chúng tôi có thể tìm kiếm tất cả các tệp kết thúc bằng phần mở rộng '.txt.' Để làm như vậy, hãy thực hiện lệnh dưới đây:
```
find . -name "*.txt"     
```
![image](https://user-images.githubusercontent.com/91528234/199426208-bab7480d-6544-4417-88ae-0fd87a6d3cc3.png)
### Tìm kiếm theo loại
* Tham số '-type' được sử dụng để chỉ định loại tệp.
* Một số loại tệp như sau:

|OPTION| ACTION |
| :---- | :---- |
f | tệp thông thường
d | thư mục
l | liên kết tượng trưng
c | thiết bị ký tự
b | khối thiết bị

## Lệnh locate
* Lệnh `locate` và lệnh `find` sử dụng để tìm kiếm một tệp theo tên. Tuy nhiên, sự khác biệt giữa cả hai lệnh là lệnh `locate` là một quá trình nền và `find` tệp trong cơ sở dữ liệu trong khi tìm kiếm lệnh trong hệ thống tệp. Lệnh 'locate' nhanh hơn nhiều so với lệnh `find`.
* Cú pháp
```
locate [OPTION]... PATTERN...  
```
* Các options:

|OPTION| ACTION |
| :---- | :---- |
| -A, --all | Nó được sử dụng để chỉ hiển thị các mục nhập phù hợp với tất cả MẪU thay vì chỉ yêu cầu một trong số chúng phải khớp. |
| -b, --basename | Nó chỉ được sử dụng để so khớp tên cơ sở với các mẫu được chỉ định. |
| -c, --count | Nó được sử dụng để viết các mục khớp số thay vì viết tên tệp trên đầu ra chuẩn. |
| -d, --database DBPATH | Nó được sử dụng để thay thế cơ sở dữ liệu mặc định bằng DBPATH. |
| -e, --existing | Nó được sử dụng để chỉ hiển thị các mục nhập tham chiếu đến các tệp hiện có trong khi lệnh được thực thi. |
| -L, --follow | Nếu tùy chọn '--existing' được chỉ định, Nó được sử dụng để kiểm tra xem tệp có tồn tại hay không và theo các liên kết tượng trưng theo sau. Nó sẽ bỏ qua các liên kết tượng trưng bị hỏng cho đầu ra. Đây là hành vi mặc định. Hành vi ngược lại có thể được chỉ định bằng cách sử dụng tùy chọn "--nofollow". |
| -h, --help | nó được sử dụng để hiển thị tài liệu trợ giúp chứa tóm tắt các tùy chọn có sẵn. |
| -i, --ignore-case | Nó được sử dụng để bỏ qua phân biệt chữ hoa chữ thường của các mẫu được chỉ định. |
| -p, --ignore-space | Nó được sử dụng để bỏ qua dấu chấm câu và dấu cách khi khớp các mẫu. |
| -t, --transliterate | Nó được sử dụng để bỏ qua các dấu trọng âm bằng cách sử dụng chuyển ngữ iconv khi khớp các mẫu. |
| -l, --limit, -n LIMIT | Nếu tùy chọn này được chỉ định, lệnh thoát thành công sau khi tìm thấy các mục LIMIT.|
| -m, --mmap | Nó được sử dụng để bỏ qua khả năng tương thích với BSD và định vị GNU. |
| -0, --null | Nó được sử dụng để phân tách các mục trên đầu ra bằng cách sử dụng ký tự ASCII NUL thay vì viết mỗi mục trên một dòng riêng biệt. |
| -S, --st Statistics | Nó được sử dụng để ghi số liệu thống kê về mỗi cơ sở dữ liệu đã đọc thành đầu ra tiêu chuẩn thay vì tìm kiếm các tệp. |
| -r, --regexp REGEXP | Nó được sử dụng để tìm kiếm một REGEXP regexp cơ bản. |
| --regex | Nó được sử dụng để mô tả tất cả MẪU dưới dạng biểu thức chính quy mở rộng. |
| -V, --version | Nó được sử dụng để hiển thị thông tin về phiên bản và giấy phép. |
| -w, --wholename | Nó chỉ được sử dụng để khớp toàn bộ tên đường dẫn trong các mẫu được chỉ định. |
## Lệnh whereis

* `Whereis` là một tiện ích dòng lệnh command line, nó cho phép bạn tìm kiếm vị trí lưu trữ của các file nhị phân, nguồn gốc và công dụng của một lệnh khác bất kì trên Linux. Và sau đây chúng ta hãy xem một chút về cú pháp của nó đã nhé.
```
whereis [OPTIONS] COMMAND...
```
* Trong đó:
	* **OPTION** là những tùy chọn mà chúng ta sẽ tìm hiểu ở phần 2
	* **COMMAND** chính là lệnh cần kiểm tra.
* Ví dụ xem thông tin lệnh bash
![image](https://user-images.githubusercontent.com/91528234/199432983-25dc9abc-ce69-45cd-8153-c9c804338871.png)
* Một số options khác:
|OPTION| ACTION |
| :---- | :---- |
| -p | Hiển thị mỗi đường |
| -s | Xem đường dẫn đến file nguồn |
| -m | lấy file man |
## Lệnh which
* lệnh `which` được sử dụng để định vị các tệp thực thi hoặc vị trí của một chương trình từ hệ thống tệp. Nó hiển thị đường dẫn nơi tệp hoặc lệnh được chỉ định được lưu trữ.
* Nếu bạn tò mò muốn biết chương trình được chỉ định được lưu trữ ở đâu, lệnh `which` sẽ giúp bạn xác định đường dẫn, thì nó khá đơn giản để sử dụng.
* Cú pháp 
```
which <program name> 
```
*  options của lệnh `which`
Lệnh nào chỉ tạo điều kiện với một tùy chọn là tùy chọn '-a'. Nó được sử dụng để hiển thị tất cả các đường dẫn cho lệnh được chỉ định. Trong một số trường hợp, máy của chúng tôi chứa hai đường dẫn khác nhau cho cùng một chương trình. Ví dụ: nó có thể là "/ usr / bin / program" hoặc "/ usr / local / bin / program". Tùy chọn '-a' sẽ hiển thị cả hai đường dẫn cho lệnh được chỉ định
![image](https://user-images.githubusercontent.com/91528234/199435167-74a3622b-98f0-4761-8789-a27c2303e90d.png)

# Runlevels and the Initialization
## Initialization ( Trình khởi tạo )
### Daemons

* **Daemon** là một loại quy trình hệ thống cụ thể chạy trong nền, không có sự tương tác với người dùng. Đúng như tên gọi, chúng ẩn nấp trong nền để chờ được triệu hồi vào một thời điểm đã định. Với mục đích của bài học này, chúng ta hãy hiểu rằng chúng là các dịch vụ được gọi là một phần của quá trình khởi động.

### Init

* Là một phần của quá trình khởi động hệ thống, BIOS (Hệ thống đầu ra đầu vào cơ bản) sẽ đảm bảo rằng phần cứng hoạt động bình thường và sau đó bắt đầu quá trình khởi động hệ điều hành bằng cách tải hạt nhân, lõi của hệ điều hành. Sau đó, hạt nhân sẽ nhìn vào một thư mục có tên /sbin cho một tệp có tên **init**. Khi nó tải, daemon init sẽ tìm kiếm một tệp có tên **inittab**. Tệp **inittab** chứa các hướng dẫn cho chương trình init, chủ yếu liên quan đến các **runlevels** mà init nên tham chiếu để khởi động hệ thống. Đặc biệt, tệp inittab sẽ thông báo quá trình init mà runlevel là mặc định cho hệ thống.

### Runlevels

* Runlevel ở dạng đơn giản nhất của chúng chỉ là một tập hợp các tập lệnh mà hệ thống sử dụng để gọi các quy trình daemon khác cung cấp nhiều dịch vụ. Các tập lệnh này xác định các tính năng khác nhau của môi trường khi hệ thống được khởi động hoặc khi người dùng gọi một cấp chạy khác trong quá trình hoạt động.
* Các số runlevel chạy từ 0 tới 6 có ý nghĩa như sau:
	* Runlevel 0: Shutdown hệ thống
	* Runlevel 1: Chế độ rescue mode, 1 user
	* Runlevels 2, 3, 4: Chế độ nhiều user, có kết nối mạng, giao diện CLI
	* Runlevel 5: Chế độ nhiều user, có kết nối mạng, giao diện đồ họa GUI.
	* Runlevel 6: Reboot hệ thống
# Managing Users and Groups
* Vì Linux là hệ điều hành nhiều người dùng (trong đó nó cho phép nhiều người dùng trên các máy tính hoặc thiết bị đầu cuối khác nhau truy cập vào một hệ thống duy nhất), bạn sẽ cần biết cách thực hiện quản lý người dùng hiệu quả: cách thêm, chỉnh sửa, tạm ngừng hoặc xóa tài khoản người dùng, cùng với việc cấp cho họ các quyền cần thiết để thực hiện các nhiệm vụ được giao.
## Thêm tài khoản người dùng

* Để thêm tài khoản người dùng mới, bạn có thể chạy một trong hai lệnh sau với quyền root.
```
# adduser [new_account]
# useradd [new_account]
```
* Khi một tài khoản người dùng mới được thêm vào hệ thống, các thao tác sau sẽ được thực hiện.

	* Thư mục chính của anh ấy / cô ấy được tạo (/home/ tên người dùng theo mặc định).

	* Các tệp ẩn sau đây được sao chép vào thư mục chính của người dùng và sẽ được sử dụng để cung cấp các biến môi trường cho phiên người dùng của họ.
	* Một hộp thư được tạo cho người dùng tại /var/spool/mail/username.

	* Một nhóm được tạo và đặt cùng tên với tài khoản người dùng mới.
### /etc/passwd
* Thông tin tài khoản đầy đủ được lưu trữ trong tệp /etc/passwd. Tệp này chứa một bản ghi cho mỗi tài khoản người dùng hệ thống và có định dạng sau (các trường được phân tách bằng dấu hai chấm).
```
[username]:[x]:[UID]:[GID]:[Comment]:[Home directory]:Default shell]
```

* Dấu x trong trường thứ hai cho biết rằng tài khoản được bảo vệ bằng mật khẩu ẩn (trong **/etc/shadow**), cần để đăng nhập với tư cách **[username]**.

* Trường **[UID]** và **[GID]** là các số nguyên đại diện cho ID người dùng và ID nhóm chính mà **[username]** thuộc về, tương ứng.

* **[Home directory]** cho biết đường dẫn tuyệt đối đến thư mục chính của **[username]** 

* **[Default shell]** là trình bao sẽ được cung cấp cho người dùng này khi họ đăng nhập hệ thống.
### /etc/group
* Thông tin nhóm được lưu trữ trong tệp /etc/group. Mỗi bản ghi có định dạng sau.
```
[Group name]:[Group password]:[GID]:[Group members]
```
* **[Group name]** tên của nhóm
* **[GID]** tương tự /etc/passwd
* **[Group members]** danh sách được phân tách bằng dấu phẩy gồm những người dùng là thành viên của **[Group name].**
# Using System Log Files
## Logging Linux
* Nhật ký hệ điều hành cung cấp nhiều thông tin chẩn đoán về máy tính của bạn và Linux không phải là ngoại lệ. Mọi thứ từ sự kiện kernel đến hành động của người dùng đều được ghi lại bằng Linux, cho phép bạn xem hầu hết mọi hành động được thực hiện trên máy chủ của mình.
## Nhật kí hệ thống Linux
* Linux có một thư mục đặc biệt để lưu trữ nhật kí được gọi là `/var/log`. Thư mục này chứa nhật kí từ chính hệ điều hành, các dịch vụ và các ứng dụng khác nhau đang chạy trên hệ thống. Dưới đây giao diện của thư mục này trên hệ thống Ubuntu điển hình.	
 ![image](https://user-images.githubusercontent.com/91528234/199452245-6017cdfe-71c7-41b3-824c-0737247e456c.png)
 * Một số nhật thế Linux quan trọng nhất bao gồm:
 * /var/log/syslog và /var/log/messages lưu trữ tất cả dữ liệu hoạt động của hệ thống toàn cầu, bao gồm cả các thông báo khởi động. Các hệ thống dựa trên Debian như Ubuntu lưu trữ dữ liệu này trong /var/log/syslog, trong khi các hệ thống dựa trên Red Hat như RHEL hoặc CentOS sử dụng /var/log/messages.
/var/log/auth.log và /var/log/secure lưu trữ tất cả các sự kiện liên quan đến bảo mật như thông tin đăng nhập, hành động của người dùng root và đầu ra từ mô-đun xác thực có thể cắm thêm (PAM). Ubuntu và Debian sử dụng /var/log/auth.log, trong khi Red Hat và CentOS sử dụng /var/log/secure.
/var/log/kern.log lưu trữ các sự kiện hạt nhân, lỗi và nhật ký cảnh báo, đặc biệt hữu ích để khắc phục sự cố hạt nhân tùy chỉnh.
/var/log/cron lưu trữ thông tin về các tác vụ đã lên lịch (cron job). Sử dụng dữ liệu này để xác minh các công việc cron của bạn đang chạy thành công.
Một số ứng dụng cũng ghi các tệp nhật ký vào thư mục này. Ví dụ: máy chủ web Apache ghi nhật ký vào thư mục /var/log/apache2 (trên Debian), trong khi MySQL ghi nhật ký vào thư mục /var/log/mysql. Một số ứng dụng cũng đăng nhập qua Syslog.
## Syslog
* `Syslog` là một tiêu chuẩn để tạo và truyền các bản ghi. Từ `syslog` có thể đề cập đến bất kỳ điều nào sau đây:

	* Dịch vụ nhật ký hệ thống nhận và xử lý các thông báo nhật ký hệ thống và lắng nghe các sự kiện bằng cách tạo một ổ cắm đặt tại `/dev/log` mà các ứng dụng có thể ghi vào. Nó có thể ghi tin nhắn vào một tệp cục bộ hoặc chuyển tiếp tin nhắn đến một máy chủ từ xa. Có nhiều cách triển khai nhật ký hệ thống khác nhau, bao gồm **rsyslogd** và **syslog-ng**.

	* Giao thức Syslog (RFC 5424) là một giao thức truyền tải chỉ định cách truyền các bản ghi qua mạng. Đây cũng là một định dạng dữ liệu xác định cách cấu trúc thư. Theo mặc định, nó sử dụng cổng 514 cho các tin nhắn văn bản rõ và cổng 6514 cho các tin nhắn được mã hóa.

	* Thông báo nhật ký hệ thống là bất kỳ nhật ký nào được định dạng theo định dạng thông báo nhật ký hệ thống và bao gồm tiêu đề và thông báo được chuẩn hóa có chứa nội dung của nhật ký.

* Vì Syslog có thể chuyển tiếp tin nhắn đến các máy chủ từ xa, nó thường được sử dụng để chuyển tiếp nhật ký hệ thống tới các giải pháp quản lý nhật ký như SolarWinds® Loggly® và SolarWinds Papertrail ™.
* Cú pháp
```
syslogd [-a] [  -d ] [  -s  ] [ -f ConfigurationFile  ] [  -m MarkInterval  ] [ -r ] [ -R ] [ -n ] [ -N ] [ -p LogName ] [ -M all ] [ -A AdditionalLog ] [-e]
```
*Các options

|OPTION| ACTION |
| :---- | :---- |
| -a | Ngăn chặn tra cứu tên máy chủ ngược lại cho các thư đến từ máy chủ từ xa và ghi lại địa chỉ IP của máy chủ từ xa trong tệp nhật ký.|
| -d | Bật gỡ lỗi. |
| -e | Chỉ định xoay nâng cao. Tất cả các tệp nén và không nén có sẵn trong thư mục nhật ký và được tạo bởi daemon syslogd đều được xem xét để luân chuyển. |
| -f | Chỉ định tệp cấu hình thay thế. |
| -m | Chỉ định số phút giữa các thông điệp lệnh đánh dấu. Nếu bạn không sử dụng cờ này, lệnh mark sẽ gửi một tin nhắn với mức độ ưu tiên LOG_INFO được gửi sau mỗi 20 phút. Tiện ích này không được kích hoạt bởi trường bộ chọn có chứa dấu hoa thị (*), sẽ chọn tất cả các tiện ích khác. |
| -M | Chỉ định không chặn các thông báo trùng lặp trong logfile. Cờ này chỉ hợp lệ nếu được sử dụng với đối số tất cả. |
| -S | Chỉ định chuyển tiếp một thông báo "rút gọn" đến một hệ thống khác (nếu nó được định cấu hình để làm như vậy) cho tất cả các thông báo nhật ký hệ thống chuyển tiếp được tạo trên hệ thống cục bộ. |
| -r | Ngăn ghi nhật ký các tin nhắn nhận được từ các máy chủ từ xa. |
| -R | Tắt thiết bị nhận tin nhắn từ mạng bằng ổ cắm miền internet. |
| -N | Loại bỏ chuỗi "Thư được chuyển tiếp từ <log_host_name>:" được thêm vào phần đầu của thông báo nhật ký hệ thống được chuyển tiếp đến máy chủ lưu trữ nhật ký từ xa. |
| -N | Ngăn ghi nhật ký thông tin ưu tiên và cơ sở cho mỗi thông báo nhật ký. |
| -P | Chỉ định tên đường dẫn thay thế cho ổ cắm datagram.
| -A | Chỉ định nhật ký bổ sung mà daemon syslogd kiểm tra. Theo mặc định, daemon syslogd kiểm tra tệp / dev / log để tìm thông báo. Nếu cờ này được chỉ định, nó cũng sẽ kiểm tra các tệp bổ sung cho các thư. Các bản ghi bổ sung có thể nằm trong đường dẫn **chroot**. |

## Rotating logs
chúng ta sẽ tìm hiểu cách tự động xoay vòng nhật ký bằng logrotate trong Linux.
### Installation
* Để cài đặt logrotate, chúng ta có thể sử dụng trình quản lý gói trong các bản phân phối Linux khác nhau.
* Trên Ubuntu, chúng ta có thể cài đặt gói bằng apt-get:
```
$ sudo apt-get update
$ sudo apt-get install -y logrotate
```
### Cú pháp lệnh
* Chạy lệnh logrotate bằng cách chỉ định danh sách các tùy chọn theo sau là các đường dẫn đến mỗi tệp cấu hình:
```
logrotate [OPTION...] <config file1> <config file2>...
```
### Tập tin cấu hình
* Cấu hình Logrotate được lưu tại `/etc/logrotate.conf`, chứa thông tin thiết lập toàn bộ log files mà Logrotate quản lý, bao gồm chu kì lặp, dung lượng file log, nén file…
```
# see "man logrotate" for details
# rotate log files weekly
weekly

# keep 4 weeks worth of backlogs
rotate 4

# create new (empty) log files after rotating old ones
create

# use date as a suffix of the rotated file
dateext

# uncomment this if you want your log files compressed
#compress

# RPM packages drop log rotation information into this directory
include /etc/logrotate.d

# no packages own wtmp and btmp -- we'll rotate them here
/var/log/wtmp {
    monthly
    create 0664 root utmp
        minsize 1M
    rotate 1
}

/var/log/btmp {
    missingok
    monthly
    create 0600 root utmp
    rotate 1
}

# system-specific logs may be also be configured here.
```
* Theo như trên, log file được rotate hàng tuần, dữ liệu log được lưu trữ trong vòng 4 file, file log mới sẽ được tạo sau khi rotate file cũ. Các log file thêm hậu tố ngày trong tên file và được nén lại bằng gzip.

* Thông tin cấu hình log file của từng ứng dụng cụ thể được lưu tại /etc/logrotate.d/

## Lựa chọn Log file được rotate

* Bạn có thể chỉ định cụ thể một hay nhiều file log với đường dẫn tuyệt đối của file log đó, phân biệt danh sách các log file cụ thể bằng khoảng trắng. Ví dụ:
```
/home/*/logs/mysql*.log
/home/*/logs/access.log /home/*/logs/error.log /home/*/logs/nginx_error.log
```
## Rotate theo thời gian
* Có 4 giá trị cấu hình tương ứng với khoảng thời gian log file sẽ được rotate.
	* Daily: mỗi ngày
	* Weekly: mỗi đầu tuần
	* Monthly: mỗi đầu tháng
	* Yearly: mỗi năm
## Rotate theo dung lượng file log
* Ta có thể quy định tiến trình rotate dựa vào dung lượng file, ví dụ nếu file đó đạt dung lượng 100mb thì tiến hành rotate. Các đơn vị kích thước file có thể sử dụng là K, M, G
```
size 100k
size 100M
size 100G
```
* Cấu hình rotate dựa theo dung lượng file luôn được ưu tiên cao hơn rotate dựa vào thời gian. Khi đó, nếu 1 file log được rotate theo cấu hình dung lượng file quy định thì thời gian rotate sẽ được khởi động lại mới.

* Ví dụ, log file được cấu hình rotate theo tuần weekly và theo dung lượng 100mb. Tuy vậy, đến giữa tuần log file được rotate do dung lượng file đạt 100M. Khi đó, Logrotate sẽ phải đợi sang tuần kế tiếp để thực hiện rotate log, do việc rotate theo size đã bỏ qua luôn thời gian của tuần này.
## Debug cấu hình LogRotate
* Nếu muốn kiểm tra cấu hình chuẩn chưa, bạn dùng tham số -d (debug) đối với các file cấu hình LogRotate riêng biệt. Ví dụ, kiểm tra toàn bộ quá trình LogRotate của Nginx:
```
logrotate -d /etc/logrotate.d/nginx
reading config file /etc/logrotate.d/nginx
reading config info for /home/*/logs/access.log /home/*/logs/error.log /home/*/logs/nginx_error.log

Handling 1 logs

rotating pattern: /home/*/logs/access.log /home/*/logs/error.log /home/*/logs/nginx_error.log  after 1 days (5 rotations)
empty log files are not rotated, old logs are removed
considering log /home/hocvps.com/logs/access.log
  log does not need rotating
considering log /home/hocvps.com/logs/error.log
  log needs rotating
considering log /home/hocvps.com/logs/nginx_error.log
  log does not need rotating
rotating log /home/hocvps.com/logs/error.log, log->rotateCount is 5
dateext suffix '-20161216'
glob pattern '-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'
previous log /home/hocvps.com/logs/error.log.1 does not exist
renaming /home/hocvps.com/logs/error.log.5.gz to /home/hocvps.com/logs/error.log.6.gz (rotatecount 5, logstart 1, i 5),
renaming /home/hocvps.com/logs/error.log.4.gz to /home/hocvps.com/logs/error.log.5.gz (rotatecount 5, logstart 1, i 4),
renaming /home/hocvps.com/logs/error.log.3.gz to /home/hocvps.com/logs/error.log.4.gz (rotatecount 5, logstart 1, i 3),
renaming /home/hocvps.com/logs/error.log.2.gz to /home/hocvps.com/logs/error.log.3.gz (rotatecount 5, logstart 1, i 2),
renaming /home/hocvps.com/logs/error.log.1.gz to /home/hocvps.com/logs/error.log.2.gz (rotatecount 5, logstart 1, i 1),
renaming /home/hocvps.com/logs/error.log.0.gz to /home/hocvps.com/logs/error.log.1.gz (rotatecount 5, logstart 1, i 0),
renaming /home/hocvps.com/logs/error.log to /home/hocvps.com/logs/error.log.1
creating new /home/hocvps.com/logs/error.log mode = 0640 uid = 498 gid = 4
running postrotate script
running script with arg /home/*/logs/access.log /home/*/logs/error.log /home/*/logs/nginx_error.log : "
                [ -f /var/run/nginx.pid ] && kill -USR1 `cat /var/run/nginx.pid`
"
removing old log /home/hocvps.com/logs/error.log.6.gz
error: error opening /home/hocvps.com/logs/error.log.6.gz: No such file or directory
```
