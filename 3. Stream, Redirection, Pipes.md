# Standard Input, Standard Output, and Standard Error
* Khi một lệnh bắt đầu chạy, thông thường có  ba tệp đã được mở: Standard Input (đầu vào tiêu chuẩn), Standard Output (đầu ra tiêu chuẩn) và Standard Error (lỗi tiêu chuẩn) (đôi khi được gọi là đầu ra lỗi hoặc đầu ra chẩn đoán). Những con số, được gọi là file descriptor (bộ mô tả tệp), được liên kết với mỗi tệp này, như sau:
  * Bộ mô tả tệp (file descriptor) 0 Đầu vào chuẩn

  * Bộ mô tả tệp (file descriptor) 1 Đầu ra chuẩn

  * Bộ mô tả tệp (file descriptor) 2 Đầu ra lỗi chuẩn (chẩn đoán)

* Một tiến trình con thường kế thừa các tệp này từ tệp cha của nó. Cả ba tệp ban đầu được gán cho máy trạm (0 cho bàn phím, 1 và 2 cho màn hình). Shell cho phép chúng được chuyển hướng đến nơi khác trước khi điều khiển được chuyển đến một lệnh.

* Khi bạn nhập một lệnh, nếu không có tên tệp nào được cung cấp, thì bàn phím của bạn là _đầu vào chuẩn_, đôi khi được ký hiệu là stdin. Khi một lệnh kết thúc, kết quả sẽ được hiển thị trên màn hình của bạn.

* Màn hình của bạn là _đầu ra tiêu chuẩn_, đôi khi được biểu thị là stdout. Theo mặc định, các lệnh lấy đầu vào từ đầu vào tiêu chuẩn và gửi kết quả đến đầu ra tiêu chuẩn.
* _Lỗi chuẩn_, đôi khi được ký hiệu là stderr, là nơi xuất hiện các thông báo lỗi. Theo mặc định, đây là màn hình của bạn.

* Các hành động mặc định này của đầu vào và đầu ra có thể khác nhau. Bạn có thể sử dụng tệp làm đầu vào và ghi kết quả của lệnh vào tệp. Đây được gọi là chuyển hướng đầu vào (input) / đầu ra (output), là một trong những tính năng mạnh mẽ của hệ điều hành UNIX.

* Kết quả đầu ra từ một lệnh, thường đi đến thiết bị đầu cuối, có thể dễ dàng được chuyển hướng đến một tệp thay thế. Điều này được gọi là _chuyển hướng đầu ra_. Điều này rất hữu ích khi bạn có nhiều đầu ra khó đọc trên màn hình hoặc khi bạn muốn ghép các tệp lại với nhau để tạo một tệp lớn hơn.

* Mặc dù không được sử dụng nhiều như chuyển hướng đầu ra, đầu vào cho một lệnh, thường đến từ bàn phím, cũng có thể được chuyển hướng từ một tệp. Điều này được gọi là _chuyển hướng đầu vào_. Việc chuyển hướng đầu vào cho phép bạn chuẩn bị trước một tệp và sau đó có lệnh đọc tệp.
# Redirecting Standard Output (Chuyển hướng đầu ra tiêu chuẩn )
* Khi ký hiệu > tên tệp được thêm vào cuối một lệnh, đầu ra của lệnh sẽ được ghi vào tên tệp đã chỉ định. Biểu tượng> được gọi là toán tử _chuyển hướng đầu ra_.

* Bất kỳ lệnh nào xuất kết quả của nó ra màn hình đều có thể gửi kết quả của nó đến một tệp.

## Redirecting Output to a File (chuyển hướng đầu ra thành tệp )
* Ví dụ: để gửi kết quả của lệnh ai tới một tệp có tên là **who** , hãy nhập:
```diff
- who > users
```
   **Lưu ý**: Nếu người dùng tệp đã tồn tại, tệp sẽ được ghi đè lên, trừ khi tùy chọn **noclobber** của lệnh **ksh** (Korn shell) hoặc **csh** (C shell) tích hợp sẵn được chỉ định.
* Để xem nội dung của _user_ , hãy nhập:
```
cat users
```
![image](https://user-images.githubusercontent.com/91528234/196892792-e9a2895f-6a4a-42a2-a8bc-ba1e6fda9717.png)
## Redirecting Output and Appending It to a File (Chuyển hướng đầu ra và gắn nó vào tệp )
* Khi _ký hiệu > > tên tệp_ được thêm vào cuối một lệnh, đầu ra của lệnh được nối vào tên tệp được chỉ định thay vì ghi lên bất kỳ dữ liệu hiện có nào. Biểu tượng > > được gọi là toán tử _chuyển hướng phần phụ_.
* Ví dụ, để nối _file2_ dến _file1_, ta nhập:
```
cat file2 > > file1
```
* **Lưu ý**: Nếu tệp file1 không tồn tại, tệp đó sẽ được tạo, trừ khi tùy chọn **noclobber** của bộ lệnh **ksh** (Korn shell) hoặc **csh** (C shell) tích hợp sẵn được chỉ định.
# Redirecting Standard Input (CHuyển hướng đầu vào chuẩn )
Khi _ký hiệu < tên tệp_ được thêm vào cuối lệnh, đầu vào của lệnh được đọc từ tên tệp đã chỉ định. _Ký hiệu_ được gọi là toán tử _chuyển hướng đầu vào_.
* **Lưu ý**: Chỉ các lệnh thường lấy dữ liệu nhập từ bàn phím mới có thể chuyển hướng nhập liệu của chúng.

Ví dụ: để gửi tệp letter1 dưới dạng thông báo tới người dùng từ chối bằng lệnh **mail**, hãy nhập:
```
mail denise < letter1
```
# Loại bỏ đầu ra với tệp /dev/null ( không hấp thụ được 😑)

* Tệp **/dev/null** là một tệp đặc biệt. Tệp này có một thuộc tính duy nhất; nó luôn luôn trống rỗng. Mọi dữ liệu bạn gửi đến **/dev/null** đều bị loại bỏ. Đây là một tính năng hữu ích khi bạn chạy một chương trình hoặc lệnh tạo ra kết quả mà bạn muốn bỏ qua.

Ví dụ: bạn có một chương trình tên là myprog chấp nhận đầu vào từ màn hình và tạo thông báo trong khi nó đang chạy mà bạn muốn bỏ qua. Để đọc đầu vào từ tệp myscript và loại bỏ thông báo đầu ra tiêu chuẩn, hãy nhập:
```
myprog <myscript> / dev / null
```

Trong ví dụ này, myprog sử dụng tệp myscript làm đầu vào và tất cả đầu ra tiêu chuẩn bị loại bỏ.
